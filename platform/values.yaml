# Values in the .global section can be accessed by both parent and child subcharts as
# .Values.global.*: https://helm.sh/docs/chart_template_guide/subcharts_and_globals/
global:
  # -- Optional domain where Seqera Platform (formerly known as Tower) will listen on.
  platformExternalDomain: example.com

  # -- Domain where user-created Platform reports are exposed at (evaluated as template), to avoid
  # Cross-Site Scripting attacks. If unset, data will be served through the main domain
  # .global.platformExternalDomain. Evaluated as a template.
  contentDomain: '{{ printf "user-data.%s" .Values.global.platformExternalDomain }}'

  # -- Seqera Platform Service name: can be the internal kubernetes hostname or an external ingress
  # hostname. Evaluated as a template.
  platformServiceAddress: '{{ printf "%s-backend" (include "common.names.fullname" .) }}'
  # -- Seqera Platform Service port.
  platformServicePort: 8080

  platformDatabase:
    # -- Platform MySQL database hostname.
    host: ""
    # -- Platform MySQL database port.
    port: 3306
    # -- Platform MySQL database name.
    database: ""
    # -- Platform MySQL database username.
    username: ""
    # -- Platform MySQL database password.
    password: ""
    # -- Name of an existing secret containing credentials for the Platform MySQL db.
    existingSecretName: ""
    # -- Key in the existing secret containing the password for the Platform MySQL db.
    existingSecretKey: TOWER_DB_PASSWORD
    # Enable encryption in transit when connecting to the external database.
    # TODO: implement support for this in the templates.
    #tls: true

  # Global Redis configuration values. Values set here will be used by multiple seqera products
  # that require Redis, unless overridden in each product's own .redis section. See README.
  redis:
    # -- Redis hostname.
    host: ""
    # -- Redis port.
    port: 6379
    # TODO: Shall we streamline this by removing the auth subsection and keeping only
    # password/secret here?
    # TODO: how should we define which redis database each product should use?
    auth:
      # -- Enable Redis authentication.
      enabled: false
      # -- Redis authentication password.
      password: ""
      # -- Name of an existing secret containing credentials for Redis.
      existingSecretName: ""
      # -- Key in the existing secret containing the password for Redis.
      existingSecretKey: TOWER_REDIS_PASSWORD
    tls:
      # -- Enable TLS when connecting to Redis.
      enabled: false

  # -- Optionally define credentials to login and fetch images from a private registry.
  #
  # - registry: ""
  #   username: ""
  #   password: ""
  #   email: someone@example.com  # Optional.
  imageCredentials: []



#######
#######
#######
#######
#######
#######
#######
#######
#######
####### needs to be renamed to platform
#######
#######
#######
#######
#######
#######
tower:
  # TODO: check the following stance:
  # Only tower.* properties can be applied through the YAML file.
  # -- Content to insert into the tower.yml file (you can use `\|-` YAML multilines)
  YAMLConfigFileContent: ""

  # -- Sender email address for user support.
  contactEmail: tower-support@example.com

  # -- JWT seed, defined as string. It is used to sign authentication tokens.
  # Either define the value as a String or a Secret, not both at the same time.
  # If neither is defined, a random 35 characters long string will be generated by Helm.
  jwtSeedString: ""
  # -- Name of the Secret containing the JWT seed.
  jwtSeedSecretName: ""
  # -- Key in the existing secret containing the JWT seed.
  jwtSeedSecretKey: TOWER_JWT_SECRET

  # -- Crypto seed, defined as string. It is used to encrypt sensitive data in the database.
  # Either define the value as a String or a Secret, not both at the same time.
  # If neither is defined, a random 35 characters long string will be generated by Helm.
  cryptoSeedString: ""
  # -- Name of the Secret containing the crypto seed.
  cryptoSeedSecretName: ""
  # -- Key in the existing secret containing the crypto seed.
  cryptoSeedSecretKey: TOWER_CRYPTO_SECRETKEY

  # TODO: should this become a list, similarly to the micronaut envs?
  # -- Enable the platforms that Platform will allow users to create environments for.
  enablePlatforms: "altair-platform,awsbatch-platform,azbatch-platform,eks-platform,googlebatch-platform,gke-platform,k8s-platform,lsf-platform,moab-platform,slurm-platform"
  # TODO: do we even need to expose this? This is currently in the default CM.
  flywayLocations: "classpath:db-schema/mysql"

  # -- Platform license key. A license key is a long alphanumeric string provided by your Seqera
  # Labs account manager.
  # Either define the value as a String or a Secret, not both at the same time.
  licenseString: ""
  # -- Name of the Secret containing the Platform license key.
  licenseSecretName: ""
  # -- Key in the existing secret containing the Platform license key.
  licenseSecretKey: TOWER_LICENSE

  smtp:
    # -- SMTP server hostname to let users authenticate through email, and to send email
    # notifications for events.
    host: ""
    # -- SMTP server port.
    port: ""
    # -- SMTP server username.
    user: ""
    # -- SMTP server password.
    password: ""
    # -- Name of an existing secret containing the SMTP password.
    existingSecretName: ""
    # -- Key in the existing secret containing the SMTP password.
    existingSecretKey: TOWER_SMTP_PASSWORD

  # -- Use AWS Simple Email Service (SES) to send Seqera emails instead of SMTP. An IAM role with
  # the appropriate permissions needs to be exposed to the cron pod, e.g. via IRSA, EKS Pod
  # Identity, etc.
  awsSesEnable: false

  # TODO: Move this into .global.platformDatabase section?
  db:
    # -- JDBC driver class name.
    driver: "org.mariadb.jdbc.Driver"
    # -- Hibernate dialect to use.
    dialect: "io.seqera.util.MySQL55DialectCollateBin"
    # -- Connection pool minimum size.
    minPoolSize: "0"
    # -- Connection pool maximum size.
    maxPoolSize: "5"
    # -- Connection pool maximum lifetime.
    maxLifetime: "60000"

  # -- URL of the Wave service Platform needs to use (evaluated as template).
  # The Wave service provided by Seqera is 'https://wave.seqera.io'.
  waveServerUrl: "https://wave.seqera.io"

  # -- Additional labels for the ConfigMap objects. Evaluated as a template.
  configMapLabels: {}
  # -- Additional labels for the Secret objects. Evaluated as a template.
  secretLabels: {}
  # -- Additional labels for the Service objects. Evaluated as a template.
  serviceLabels: {}
  # -- Additional annotations for the ConfigMap objects. Evaluated as a template.
  configMapAnnotations: {}
  # -- Additional annotations for the Secret objects. Evaluated as a template.
  secretAnnotations: {}
  # -- Additional annotations for the Service objects. Evaluated as a template.
  serviceAnnotations: {}

# Redis configuration values: for more details refer to .global.redis. These values take precedence
# over values in .global.redis.
redis:
  # -- Redis hostname.
  host: ""
  # -- Redis port.
  port: 6379
  auth:
    # -- Enable Redis authentication.
    enabled: false
    # -- Redis authentication password.
    password: ""
    # TODO: check whether creating the secret with extraDeploy and passing it here can cause race
    # conditions
    # -- Name of an existing secret containing credentials for Redis.
    existingSecretName: ""
    # -- Key in the existing secret containing the password for Redis.
    existingSecretKey: TOWER_REDIS_PASSWORD
  tls:
    # -- Enable TLS when connecting to Redis.
    enabled: false
  # -- Prefix for the Redis database to use.
  prefix: ""

# -- Array of extra objects to deploy with the release.
#
# extraDeploy:
#   - apiVersion: v1
#     kind: MyExtraObjectKind
#     ...
#   - apiVersion: v1
#     kind: AnotherExtraObjectKind
#     ...
extraDeploy: []

# -- Annotations to add to all deployed objects.
commonAnnotations: {}
# -- Labels to add to all deployed objects.
commonLabels: {}

# Options specific to the Platform backend deployment.
backend:
  image:
    # -- Backend container image registry.
    registry: cr.seqera.io
    # -- Backend container image repository.
    repository: private/nf-tower-enterprise/backend
    # -- Backend container image tag.
    # @default -- {{ .chart.AppVersion }}
    tag: ""
    # -- Backend container image digest in the format 'sha256:1234abcdef'.
    digest: ""

    # -- imagePullPolicy for the backend container.
    # Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'.
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- Optional list of imagePullSecrets.
    # Secrets must be already created in the same namespace, e.g. with the extraDeploy array above.
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    #
    # pullSecrets:
    #   - myRegistryKeySecretName
    pullSecrets: []

  # -- List of Micronaut Environments to enable on the backend pod.
  micronautEnvironments: [prod, redis, ha]

  service:
    # -- Backend Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort.
    type: ClusterIP
    http:
      # -- Service name to use.
      name: http
      # The external port is defined as the global variable .global.platformServicePort, so it can
      # be used by subcharts too.

      # TODO: targetPort is hardcoded for now, needs engineering time to make it configurable.
      # -- The port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port).
      # targetPort: 8080
      # -- (int) Service node port, only used when service.type is Nodeport or LoadBalancer.
      # Choose port between 30000-32767, unless the cluster was configured differently than default.
      nodePort: null
    # TODO: do we need the jmx service??
    # -- Other services that should live in the Service object.
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    extraServices:
      - name: jmx
        port: 1099
        targetPort: 1099
        # Only used when service.type is Nodeport or LoadBalancer.
        # To set explicitly, choose port between 30000-32767 (unless your cluster was configured differently).
        # nodePort: ""  # Optional.
    # -- Extra Service options to place under .spec (e.g. clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs, etc). Evaluated as a template.
    extraOptions: {}

  # -- Additional init containers for the backend pod. Evaluated as a template.
  initContainers: []

  # -- Override default container command (useful when using custom images).
  command: []
  # -- Override default container args (useful when using custom images).
  args: []

  # -- Additional labels for the backend pod. Evaluated as a template.
  podLabels: {}
  # -- Additional annotations to apply to the pods (e.g. Prometheus, etc). Evaluated as a template.
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. replicas, strategy, revisionHistoryLimit, etc).
  # Evaluated as a template.
  #
  # extraOptionsSpec:
  #   replicas: 2
  #   strategy:
  #     rollingUpdate:
  #       maxUnavailable: x
  #       maxSurge: y
  extraOptionsSpec: {}
  # -- Extra options to place under .spec.template.spec (e.g. nodeSelector, affinity, restartPolicy,
  # etc). Evaluated as a template.
  #
  # extraOptionsTemplateSpec:
  #   nodeSelector:
  #     service: myspecialnodegroup
  extraOptionsTemplateSpec: {}

  # -- Extra environment variables to set on the backend pod.
  #
  # extraEnvVars:
  #   - name: "MY_SPECIAL_ENVIRONMENT_VARIABLE"
  #     value: "set-a-value-here"
  extraEnvVars: []
  # -- ConfigMap containing extra env vars.
  extraEnvVarsCM: ""
  # -- Secret containing extra env vars.
  extraEnvVarsSecret: ""
  # -- Extra volumes to be added to the deployment (evaluated as template). Requires setting
  # `extraVolumeMounts`.
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # `extraVolumes`.
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration.
  podSecurityContext:
    # -- Enable backend pods Security Context.
    enabled: true
    # -- Sets the GID that Kubernetes will apply to mounted volumes and created files so processes
    # in the pod can share group-owned access.
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable backend containers Security Context
    enabled: true
    # -- Specifies the numeric UID the container processes should run as (overrides container image
    # default).
    runAsUser: 101
    # -- Boolean that requires the container to run as a non-root UID (prevents starting if UID 0).
    runAsNonRoot: true
    # -- Mounts the container root filesystem read-only to prevent in-place writes or tampering.
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container.
    capabilities:
      drop:
        - ALL

  # -- Set container requests and limits for different resources like CPU or memory.
  # .requests are the minimum CPU/memory resources the scheduler uses to place a pod; the kubelet
  # then guarantees at least these resources to the pod. .limits are the maximum resources a
  # container is allowed to use.
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user.
  #
  # requests:
  #   requests:
  #     cpu: "1"
  #     memory: "1000Mi"
  #   limits:
  #     memory: "3000Mi"
  resources: {}

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe.
    enabled: false
    # -- Longer initial wait to accommodate slow-starting apps.
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting.
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses.
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate restarts).
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable liveness/readiness.
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe.
    enabled: true
    # -- Delay before first check (normal start timing).
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation.
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness.
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart).
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures.
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe.
    enabled: true
    # -- Delay before first check (normal start timing).
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation.
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly.
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container.
    failureThreshold: 10
    # -- Typically 1 (usually ignored).
    successThreshold: 1

# Options specific to the Platform frontend deployment.
frontend:
  image:
    # -- Frontend container image registry.
    registry: cr.seqera.io
    # -- Frontend container image repository.
    repository: private/nf-tower-enterprise/frontend
    # -- Specify a tag to override the version defined in .Chart.appVersion.
    # @default -- {{ .chart.AppVersion }}-unprivileged
    tag: ""
    # -- Frontend container image digest in the format 'sha256:1234abcdef'.
    digest: ""

    # -- imagePullPolicy for the frontend container.
    # Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    # ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- Optional list of imagePullSecrets.
    # Secrets must be manually created in the same namespace. See the extraDeploy array above.
    # ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    #
    # pullSecrets:
    #   - myRegistryKeySecretName
    pullSecrets: []

  service:
    # -- Frontend Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort.
    type: ClusterIP
    http:
      # -- Service name to use.
      name: http
      # -- Service port.
      port: 80
      # -- The port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port).
      targetPort: 8083
      # -- (int) Service node port, only used when service.type is Nodeport or LoadBalancer.
      # Choose port between 30000-32767, unless the cluster was configured differently than default.
      nodePort: null
    # -- Other services that should live in the Service object.
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #
    # extraServices:
    # - name: myspecialservice
    #   port: 1234
    #   targetPort: 5678
    extraServices: []
    # -- Extra Service options to place under .spec (e.g. clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs, etc). Evaluated as a template.
    extraOptions: {}

  # Add additional init containers to the pod. Evaluated as a template.
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the frontend pod. Evaluated as a template.
  podLabels: {}
  # -- Additional annotations to apply to the pods (e.g. Prometheus, etc). Evaluated as a template.
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. replicas, strategy, revisionHistoryLimit, etc).
  # Evaluated as a template.
  #
  # extraOptionsSpec:
  #   replicas: 2
  #   strategy:
  #     rollingUpdate:
  #       maxUnavailable: x
  #       maxSurge: y
  extraOptionsSpec: {}
  # -- Extra options to place under .spec.template.spec (e.g. nodeSelector, affinity, restartPolicy,
  # etc). Evaluated as a template.
  #
  # extraOptionsTemplateSpec:
  #   nodeSelector:
  #     service: myspecialnodegroup
  extraOptionsTemplateSpec: {}

  # -- Extra environment variables to set on the frontend pod.
  #
  # extraEnvVars:
  #   - name: "MY_SPECIAL_ENVIRONMENT_VARIABLE"
  #     value: "set-a-value-here"
  extraEnvVars: []
  # TODO: extraEnvVarsCM should be a list
  # -- ConfigMap containing extra env vars.
  extraEnvVarsCM: ""
  # -- Secret containing extra env vars.
  extraEnvVarsSecret: ""
  # -- Extra volumes to be added to the deployment (evaluated as template). Requires setting
  # `extraVolumeMounts`.
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # `extraVolumes`.
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration.
  podSecurityContext:
    # -- Enable backend pods Security Context.
    enabled: true
    # -- Sets the GID that Kubernetes will apply to mounted volumes and created files so processes
    # in the pod can share group-owned access.
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable backend containers Security Context
    enabled: true
    # -- Specifies the numeric UID the container processes should run as (overrides container image
    # default).
    runAsUser: 101
    # -- Boolean that requires the container to run as a non-root UID (prevents starting if UID 0).
    runAsNonRoot: true
    # -- Mounts the container root filesystem read-only to prevent in-place writes or tampering.
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container.
    capabilities:
      drop:
        - ALL

  # -- Set container requests and limits for different resources like CPU or memory.
  # .requests are the minimum CPU/memory resources the scheduler uses to place a pod; the kubelet
  # then guarantees at least these resources to the pod. .limits are the maximum resources a
  # container is allowed to use.
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user.
  #
  # requests:
  #   requests:
  #     cpu: "1"
  #     memory: "1000Mi"
  #   limits:
  #     memory: "3000Mi"
  resources: {}

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe.
    enabled: false
    # -- Longer initial wait to accommodate slow-starting apps.
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting.
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses.
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate restarts).
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable liveness/readiness.
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe.
    enabled: false
    # -- Delay before first check (normal start timing).
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation.
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness.
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart).
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures.
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe.
    enabled: false
    # -- Delay before first check (normal start timing).
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation.
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly.
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container.
    failureThreshold: 10
    # -- Typically 1 (usually ignored).
    successThreshold: 1

# Options specific to the Platform cron deployment.
cron:
  image:
    # -- Cron container image registry.
    registry: cr.seqera.io
    # -- Cron container image repository.
    repository: private/nf-tower-enterprise/backend
    # -- Cron container image tag.
    # @default -- {{ .chart.AppVersion }}
    tag: ""
    # -- Cron container image digest in the format 'sha256:1234abcdef'.
    digest: ""

    # -- imagePullPolicy for the cron container.
    # Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- Optional list of imagePullSecrets.
    # Secrets must be manually created in the same namespace. See the extraDeploy array above.
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    #
    # pullSecrets:
    #   - myRegistryKeySecretName
    pullSecrets: []

  # -- List of Micronaut Environments to enable on the cron pod.
  micronautEnvironments: [prod, redis, cron]

  service:
    # -- Cron Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort.
    type: ClusterIP
    http:
      # -- Service name to use.
      name: http
      # -- Service port.
      port: 8080
      # -- The port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port).
      targetPort: 8082
      # -- (int) Service node port, only used when service.type is Nodeport or LoadBalancer.
      # Choose port between 30000-32767, unless the cluster was configured differently than default.
      nodePort: null
    # -- Other services that should live in the Service object.
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #
    # extraServices:
    # - name: myspecialservice
    #   port: 1234
    #   targetPort: 5678
    extraServices: []
    # Extra Service options to place under .spec (e.g. clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs, etc). Evaluated as a template.
    extraOptions: {}

  # -- Additional init containers for the cron pod. Evaluated as a template.
  initContainers: []

  # -- Override default container command (useful when using custom images).
  command: []
  # -- Override default container args (useful when using custom images).
  args: []

  # -- Additional labels for the cron pod. Evaluated as a template.
  podLabels: {}
  # -- Additional annotations to apply to the pods (e.g. Prometheus, etc). Evaluated as a template.
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. revisionHistoryLimit, etc). Evaluated as a template.
  # Note that cron deployment needs to have a single replica with Recreate strategy.
  #
  # extraOptionsSpec:
  #   revisionHistoryLimit: 4
  extraOptionsSpec: {}
  # -- Extra options to place under .spec.template.spec (e.g. nodeSelector, affinity, restartPolicy,
  # etc). Evaluated as a template.
  #
  # extraOptionsTemplateSpec:
  #   nodeSelector:
  #     service: myspecialnodegroup
  extraOptionsTemplateSpec: {}

  # -- Extra environment variables to set on the cron pod.
  #
  # extraEnvVars:
  #   - name: "MY_SPECIAL_ENVIRONMENT_VARIABLE"
  #     value: "set-a-value-here"
  extraEnvVars: []
  # -- ConfigMap containing extra env vars.
  extraEnvVarsCM: ""
  # -- Secret containing extra env vars.
  extraEnvVarsSecret: ""
  # -- Extra volumes to be added to the deployment (evaluated as template). Requires setting
  # `extraVolumeMounts`.
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # `extraVolumes`.
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration.
  podSecurityContext:
    # -- Enable backend pods Security Context.
    enabled: true
    # -- Sets the GID that Kubernetes will apply to mounted volumes and created files so processes
    # in the pod can share group-owned access.
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable backend containers Security Context
    enabled: true
    # -- Specifies the numeric UID the container processes should run as (overrides container image
    # default).
    runAsUser: 101
    # -- Boolean that requires the container to run as a non-root UID (prevents starting if UID 0).
    runAsNonRoot: true
    # -- Mounts the container root filesystem read-only to prevent in-place writes or tampering.
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container.
    capabilities:
      drop:
        - ALL

  # -- Set container requests and limits for different resources like CPU or memory.
  # .requests are the minimum CPU/memory resources the scheduler uses to place a pod; the kubelet
  # then guarantees at least these resources to the pod. .limits are the maximum resources a
  # container is allowed to use.
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # We usually recommend not to specify default resources and to leave this as a conscious
  # choice for the user.
  #
  # requests:
  #   requests:
  #     cpu: "1"
  #     memory: "1000Mi"
  #   limits:
  #     memory: "3000Mi"
  resources: {}

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe.
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe.
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template.
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Longer initial wait to accommodate slow-starting apps.
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting.
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses.
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate restarts).
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable liveness/readiness.
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe.
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe.
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template.
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Delay before first check (normal start timing).
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation.
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness.
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart).
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures.
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe.
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe.
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template.
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Delay before first check (normal start timing).
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation.
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly.
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container.
    failureThreshold: 10
    # -- Typically 1 (usually ignored).
    successThreshold: 1

  dbMigrationInitContainer:
    image:
      # -- Database migration container image registry.
      registry: cr.seqera.io
      # -- Database migration container image repository.
      repository: private/nf-tower-enterprise/migrate-db
      # -- Specify a tag to override the version defined in .Chart.appVersion.
      # @default -- {{ .chart.AppVersion }}
      tag: ""
      # -- Database migration container image digest in the format 'sha256:1234abcdef'.
      digest: ""

      # -- imagePullPolicy for the database migration init container.
      # Defaults to 'Always' if image tag is 'latest', else set to 'IfNotPresent'
      # ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
      pullPolicy: IfNotPresent

      # -- Optional list of imagePullSecrets.
      # Secrets must be manually created in the same namespace. See the extraDeploy array above.
      # ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      #
      # pullSecrets:
      #   - myRegistryKeySecretName
      pullSecrets: []

    # -- Extra environment variables to set on the frontend pod.
    #
    # extraEnvVars:
    #   - name: "MY_SPECIAL_ENVIRONMENT_VARIABLE"
    #     value: "set-a-value-here"
    extraEnvVars: []
    # TODO: extraEnvVarsCM should be a list
    # -- ConfigMap containing extra env vars.
    extraEnvVarsCM: ""
    # -- Secret containing extra env vars.
    extraEnvVarsSecret: ""
    # -- Extra volumes to be added to the deployment (evaluated as template). Requires setting
    # `extraVolumeMounts`.
    extraVolumes: []
    # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
    # `extraVolumes`.
    extraVolumeMounts: []

    # Configure Init Container Security Context.
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      # -- Enable backend containers Security Context
      enabled: true
      # -- Specifies the numeric UID the container processes should run as (overrides container image
      # default).
      runAsUser: 101
      # -- Boolean that requires the container to run as a non-root UID (prevents starting if UID 0).
      runAsNonRoot: true
      # -- Mounts the container root filesystem read-only to prevent in-place writes or tampering.
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container.
      capabilities:
        drop:
          - ALL

    # -- Set container requests and limits for different resources like CPU or memory.
    # .requests are the minimum CPU/memory resources the scheduler uses to place a pod; the kubelet
    # then guarantees at least these resources to the pod. .limits are the maximum resources a
    # container is allowed to use.
    # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    # We usually recommend not to specify default resources and to leave this as a conscious
    # choice for the user.
    #
    # requests:
    #   requests:
    #     cpu: "1"
    #     memory: "1000Mi"
    #   limits:
    #     memory: "3000Mi"
    resources: {}

# Define container images for various init containers.
initContainersUtils:
  # Image for the init container that waits for the MySQL database to be ready.
  waitForMySQLImage:
    registry: ""
    repository: mysql
    tag: "9"
    # Digest must be in the format 'sha256:1234abcdef'.
    digest: ""
    pullPolicy: IfNotPresent
  # Image for the init container that waits for Redis to be ready.
  waitForRedisImage:
    registry: ""
    repository: redis
    tag: "7"
    # Digest must be in the format 'sha256:1234abcdef'.
    digest: ""
    pullPolicy: IfNotPresent
  # Image for the Backend init container that waits for Tower Cron to be ready.
  waitForCronImage:
    registry: ""
    repository: curlimages/curl
    tag: "latest"
    # Digest must be in the format 'sha256:1234abcdef'.
    digest: ""
    pullPolicy: IfNotPresent

serviceAccount:
  # -- Name of an existing ServiceAccount. If not set, a new ServiceAccount is generated.
  name: ""
  # -- Additional annotations for the Tower ServiceAccount to generate.
  annotations: {}
  # -- Names of Secrets containing credentials to pull images from registries.
  imagePullSecretNames: []
  # -- Whether to automount service account token when the server service account is generated.
  automountServiceAccountToken: false

ingress:
  # -- Enable ingress for Platform.
  enabled: false

  # -- Path for the main ingress rule.
  # Note: this needs to be set to '/*' to be used with AWS ALB ingress controller.
  path: "/"

  # -- Path for the content domain ingress rule.
  # Note: this needs to be set to '/*' to be used with AWS ALB ingress controller.
  contentPath: "/"

  # -- Default path type for the Ingress.
  defaultPathType: "ImplementationSpecific"

  # -- Optionally configure the default service for the ingress (evaluated as template).
  # Important: make sure only one defaultBackend is defined across the k8s cluster: if the
  # ingress doesn't reconcile successfully, 'describe ingress <name>' will report problems.
  #
  # defaultBackend:
  #   service:
  #     name: '{{ printf "%s-frontend" (include "common.names.fullname" .) }}'
  #     port:
  #       number: '{{ .Values.frontend.service.http.port }}'
  defaultBackend: {}

  # -- Additional hosts you want to include. Evaluated as a template.
  #
  # extraHosts:
  #   - host: myhost.example.com
  #     paths:
  #       - path: /mypath
  #         pathType: Prefix  # Optional, defaults to defaultPathType value
  #         serviceName: my-service
  #         portNumber: 8123
  extraHosts: []
  # -- Ingress annotations specific to your load balancer. Evaluated as a template.
  annotations: {}
  # -- Additional labels for the ingress object. Evaluated as a template.
  extraLabels: {}
  # -- Name of the ingress class (replaces deprecated annotation 'kubernetes.io/ingress.class').
  ingressClassName: ""
  # -- TLS configuration. Evaluated as a template.
  tls: []
