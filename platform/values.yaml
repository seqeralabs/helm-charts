# Copyright (c) 2025 - 2026 Seqera Labs
# All rights reserved.
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This values.yaml file contains the default values for the Seqera Platform Helm chart.
# Users can override these values by providing their own values.yaml file or by using --set flags
# during Helm installation or upgrade. Refer to the README.md file for more instructions on the most
# important values to set and more details on the product. The README.md file also contains a table
# view of all the available configuration options detailed in this values.yaml file. We recommend
# copying the content of this values.yaml file to an empty file, remove the values you don't need to
# change, and set the desired values for your deployment.
#
# More charts are stored under the charts/ directory and each of them comes with its own values.yaml
# file. The subcharts are designed to be used alongside this main Platform chart, but they can also
# be used independently if desired. To configure the subcharts as part of the Platform deployment,
# refer to the respective values.yaml files and check the condition field in the Chart.yaml file to
# see how to enable/disable them and how to nest their values.

# Values in the .global section can be accessed by both parent and child subcharts as
# .Values.global.*: https://helm.sh/docs/chart_template_guide/subcharts_and_globals/
global:
  # -- Domain where Seqera Platform listens
  platformExternalDomain: example.com

  # -- Domain where user-created Platform reports are exposed, to avoid Cross-Site Scripting (XSS)
  # attacks. If unset, data is served through the main domain
  # `.global.platformExternalDomain`. Evaluated as a template
  contentDomain: '{{ printf "user-data.%s" .Values.global.platformExternalDomain }}'

  # -- Seqera Platform Service name: can be the internal Kubernetes hostname or an external ingress
  # hostname. Evaluated as a template
  platformServiceAddress: '{{ printf "%s-platform-backend" .Release.Name | lower }}'
  # -- Seqera Platform Service port
  platformServicePort: 8080

  # -- Domain where the Studios service listens. Make sure the TLS certificate covers this and its
  # wildcard subdomains. Evaluated as a template
  studiosDomain: '{{ printf "studios.%s" .Values.global.platformExternalDomain }}'
  # -- Base URL for Studios connections: can be any value, since each session will use a unique
  # subdomain under `.global.studiosDomain` anyway to connect. Evaluated as a template
  studiosConnectionUrl: '{{ printf "https://connect.%s" (tpl .Values.global.studiosDomain $) }}'

  # -- Optional credentials to log in and fetch images from a private registry. These credentials
  # are shared with all the subcharts automatically
  imageCredentials: []
  # imageCredentials:
  # - registry: ""
  #   username: ""
  #   password: ""
  #   email: someone@example.com  # Optional

platformDatabase:
  # -- Platform MySQL database hostname
  host: ""
  # -- Platform MySQL database port
  port: 3306
  # -- Platform MySQL database name
  name: ""
  # -- Platform MySQL database username
  username: ""
  # -- Platform MySQL database password
  password: ""
  # -- Name of an existing Secret containing credentials for the Platform MySQL database, as an
  # alternative to the password field. Note: the Secret must already exist in the same namespace at
  # the time of deployment
  existingSecretName: ""
  # -- Key in the existing Secret containing the password for the Platform MySQL database
  # @default -- `"TOWER_DB_PASSWORD"`
  existingSecretKey: ""
  # -- Database driver. Possible options: "mariadb" (or its alias "mysql")
  driver: "mariadb"
  # -- Connection options to compose in the driver URL according to the driver used. The only
  # driver that can be set is 'mariadb'
  connectionOptions:
    # -- Connection options to use with the MariaDB driver. For the full list of supported
    # options see:
    # https://mariadb.com/docs/connectors/mariadb-connector-j/about-mariadb-connector-j
    mariadb:
      # permitMysqlScheme=true allows the MariaDB driver to communicate with MySQL databases.
      - permitMysqlScheme=true
      # sslMode enables TLS encryption with varying levels of certificate acceptance criteria.
      # Other options allow the enabling or disabling of specific TLS ciphers, the path to the
      # server's CA certificate, etc.
      # - sslMode=verify-ca
  # -- Hibernate dialect to use, depending on the database version. Possible options: mysql-8
  # (default), mariadb-10
  dialect: "mysql-8"
  # -- Connection pool minimum size
  minPoolSize: "2"
  # -- Connection pool maximum size
  maxPoolSize: "10"
  # -- Connection pool maximum lifetime
  maxLifetime: "180000"

platform:
  # TODO: rename variable?
  # -- Content to insert into the tower.yml file (you can use `\|-` YAML multilines). See
  # https://docs.seqera.io/platform-enterprise/enterprise/configuration/overview
  YAMLConfigFileContent: ""

  # -- Sender email address for user support
  contactEmail: support@example.com

  # -- JWT seed, defined as string, used to sign authentication tokens
  # Define the value as a String or a Secret, not both at the same time
  # If neither is defined, Helm generates a random 35-character string
  jwtSeedString: ""
  # -- Name of an existing Secret containing the JWT seed, as an alternative to the string field.
  # Note: the Secret must already exist in the same namespace at the time of deployment
  jwtSeedSecretName: ""
  # -- Key in the existing Secret containing the JWT seed
  # @default -- `"TOWER_JWT_SECRET"`
  jwtSeedSecretKey: ""

  # -- Crypto seed, defined as string, used to encrypt sensitive data in the database.
  # Note: this needs to be a stable value that doesn't change between deployments, otherwise
  # encrypted data in the database will become inaccessible.
  # Either define the value as a String or a Secret, not both at the same time.
  # If neither is defined, a random 35 characters long string will be generated by Helm
  cryptoSeedString: ""
  # -- Name of an existing Secret containing the crypto seed, as an alternative to the string field.
  # Note: the Secret must already exist in the same namespace at the time of deployment
  cryptoSeedSecretName: ""
  # -- Key in the existing Secret containing the crypto seed
  # @default -- `"TOWER_CRYPTO_SECRETKEY"`
  cryptoSeedSecretKey: ""

  # -- List of execution backends to enable. At least one is required. See
  # https://docs.seqera.io/platform-enterprise/enterprise/configuration/overview#compute-environments
  executionBackends:
    - altair-platform
    - awsbatch-platform
    - awscloud-platform
    - azbatch-platform
    - azcloud-platform
    - eks-platform
    - gke-platform
    - googlebatch-platform
    - googlecloud-platform
    - k8s-platform
    - local-platform
    - lsf-platform
    - moab-platform
    - slurm-platform

  # -- Platform license key. A license key is a long alphanumeric string provided by your Seqera
  # account manager
  # Define the value as a String or a Secret, not both at the same time
  licenseString: ""
  # -- Name of an existing Secret containing the Platform license key, as an alternative to the
  # string field. Note: the Secret must already exist in the same namespace at the time of
  # deployment
  licenseSecretName: ""
  # -- Key in the existing Secret containing the Platform license key
  # @default -- `"TOWER_LICENSE"`
  licenseSecretKey: ""

  # -- OIDC private key in PEM format, base64-encoded.
  oidcPrivateKeyBase64: ""
  # -- Name of an existing Secret containing the OIDC private key in PEM format, as an alternative
  # to the base64-encoded string field. Note: the Secret must already exist in the same namespace at
  # the time of deployment
  oidcPrivateKeySecretName: ""
  # -- Key in the existing Secret containing the OIDC private key in PEM format
  # @default -- `"oidc.pem"`
  oidcPrivateKeySecretKey: ""

  smtp:
    # -- SMTP server hostname to let users authenticate through email, and to send email
    # notifications for events
    host: ""
    # -- SMTP server port
    port: ""
    # -- SMTP server username
    user: ""
    # -- SMTP server password
    password: ""
    # -- Name of an existing secret containing the SMTP password
    existingSecretName: ""
    # -- Key in the existing Secret containing the SMTP password
    # @default -- `"TOWER_SMTP_PASSWORD"`
    existingSecretKey: ""

  # -- URL of the Wave service Platform uses. Evaluated as a template.
  # The Wave service provided by Seqera is `https://wave.seqera.io`
  waveServerUrl: "https://wave.seqera.io"

  dataExplorer:
    # -- Enable the Data Explorer feature:
    # https://docs.seqera.io/platform-enterprise/data/data-explorer
    enabled: false

  # Seqera Studios configuration
  studios:
    # tools[*] can be any name ..
    # adding a deprecated and recommended version for each tool to allow upgrading versions

    # -- Map of tools to make available in Studios. Recommended and deprecated versions can be
    # specified for each tool to allow upgrading from an older version. Refer to the documentation
    # for more details:
    # https://docs.seqera.io/platform-enterprise/studios/managing#migrate-a-studio-from-an-earlier-container-image-template
    tools:
      jupyter:
        tool: jupyter
        recommended: public.cr.seqera.io/platform/data-studio-jupyter:4.2.5-0.8
        deprecated: public.cr.seqera.io/platform/data-studio-jupyter:4.1.5-0.7.1

      vscode:
        tool: vscode
        recommended: public.cr.seqera.io/platform/data-studio-vscode:1.101.2-0.8
        deprecated: public.cr.seqera.io/platform/data-studio-vscode:1.93.1-0.8

      rstudio:
        tool: rstudio
        recommended: public.cr.seqera.io/platform/data-studio-ride:2025.04.1-0.8

      xpra:
        tool: xpra
        recommended: public.cr.seqera.io/platform/data-studio-xpra:6.2.0-r2-1-0.8
    # .platform.studios.tools expects a map: the key can be any name, the only required field is the
    # recommended.
    # TODO: tool field, icon, experimental. add full example

  # -- Additional labels for the ConfigMap objects. Evaluated as a template
  configMapLabels: {}
  # -- Additional labels for the Secret objects. Evaluated as a template
  secretLabels: {}
  # -- Additional labels for the Service objects. Evaluated as a template
  serviceLabels: {}
  # -- Additional annotations for the ConfigMap objects. Evaluated as a template
  configMapAnnotations: {}
  # -- Additional annotations for the Secret objects. Evaluated as a template
  secretAnnotations: {}
  # -- Additional annotations for the Service objects. Evaluated as a template
  serviceAnnotations: {}

# Note that Platform currently doesn't support specifying a Redis database within a Redis instance
redis:
  # -- Redis hostname
  host: ""
  # -- Redis port
  port: 6379
  # -- Redis password if the installation requires it
  password: ""
  # -- Name of an existing Secret containing credentials for Redis, as an alternative to the
  # password field. Note: the Secret must already exist in the same namespace at the time of
  # deployment
  existingSecretName: ""
  # -- Key in the existing Secret containing the password for Redis
  # @default -- `"TOWER_REDIS_PASSWORD"`
  existingSecretKey: ""
  # -- Enable TLS when connecting to Redis
  enableTls: false

# Options specific to the Platform backend deployment
backend:
  image:
    # -- Backend container image registry
    registry: ""
    # -- Backend container image repository
    repository: private/nf-tower-enterprise/backend
    # -- Backend container image tag
    # @default -- `"{{ .chart.AppVersion }}"`
    tag: ""
    # -- Backend container image digest in the format `sha256:1234abcdef`
    digest: ""

    # -- imagePullPolicy for the backend container
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- List of imagePullSecrets
    # Secrets must be created in the same namespace, for example using the .extraDeploy array
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    pullSecrets: []
    # pullSecrets:
    #   - myRegistryKeySecretName

  # -- List of Micronaut Environments to enable on the backend pod
  micronautEnvironments: [prod, redis, ha]

  service:
    # -- Backend Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort
    type: ClusterIP
    http:
      # -- Service name to use
      name: http
      # The external port is defined as the global variable
      # `.global.platformServicePort`, so it can be used by subcharts too

      # -- Port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port). Platform v25.3+ only; previous
      # versions were hardcoded to 8080
      targetPort: 8080
      # -- Service node port, only used when service.type is Nodeport or LoadBalancer
      # Choose port between 30000-32767, unless the cluster was configured differently than default
      nodePort: null

    # -- Other services that should live in the Service object
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    extraServices: []
    # extraServices:
    # - name: myspecialservice
    #   port: 1234
    #   targetPort: 5678
    #   nodePort: null

    # -- Extra Service options to place under .spec (for example, clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs). Evaluated as a template
    extraOptions: {}

  # -- Additional init containers for the backend pod. Evaluated as a template
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the backend pod. Evaluated as a template
  podLabels: {}
  # -- Additional annotations for the backend pod. Evaluated as a template
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. replicas, strategy, revisionHistoryLimit, etc).
  # Evaluated as a template
  extraOptionsSpec:
    replicas: 3
  # extraOptionsSpec:
  #   replicas: 2
  #   strategy:
  #     rollingUpdate:
  #       maxUnavailable: x
  #       maxSurge: y

  # -- Extra options to place under .spec.template.spec (e.g. nodeSelector, affinity, restartPolicy,
  # etc). Evaluated as a template
  extraOptionsTemplateSpec: {}
  # extraOptionsTemplateSpec:
  #   nodeSelector:
  #     service: myspecialnodegroup

  # -- Extra environment variables to set on the backend pod
  extraEnvVars: []
  # extraEnvVars:
  #   - name: "CUSTOM_ENV_VAR"
  #     value: "set-a-value-here"

  # -- ConfigMap containing extra env vars
  extraEnvVarsCMs: []
  # -- Secret containing extra env vars
  extraEnvVarsSecrets: []
  # -- Extra volumes to be added to the deployment (evaluated as template). Requires setting
  # `extraVolumeMounts`
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # `extraVolumes`
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration
  podSecurityContext:
    # -- Enable pod Security Context
    enabled: true
    # -- Sets the GID that Kubernetes will apply to mounted volumes and created files so processes
    # in the pod can share group-owned access
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable container Security Context
    enabled: true
    # -- UID the container processes run as (overrides container image default)
    runAsUser: 101
    # -- Boolean that requires the container to run as a non-root UID (prevents starting if UID 0)
    runAsNonRoot: true
    # -- Mounts the container root filesystem read-only to prevent in-place writes or tampering
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container
    capabilities:
      drop:
        - ALL

  # -- Container requests and limits for different resources like CPU or memory
  resources: {}
  # `.requests` are the minimum CPU/memory resources the scheduler uses to place a pod;
  # the kubelet then guarantees at least these resources to the pod. `.limits` are the
  # maximum resources a container is allowed to use
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # Seqera recommends tuning resources to match the expected workload. The following are
  # sensible defaults to start with:
  # resources:
  #   requests:
  #     cpu: "1"
  #     memory: "4000Mi"
  #   limits:
  #     memory: "4000Mi"

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template. Note: before v25.3 this was
      # hardcoded to 8080
      port: '{{ .Values.backend.service.http.targetPort }}'
    # -- Longer initial wait to accommodate slow-starting apps
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate
    # restarts)
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable
    # liveness/readiness
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template. Note: before v25.3 this was
      # hardcoded to 8080
      port: '{{ .Values.backend.service.http.targetPort }}'
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart)
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template. Note: before v25.3 this was
      # hardcoded to 8080
      port: '{{ .Values.backend.service.http.targetPort }}'
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container
    failureThreshold: 10
    # -- Typically 1 (usually ignored)
    successThreshold: 1

# Options specific to the Platform frontend deployment
frontend:
  image:
    # -- Frontend container image registry
    registry: ""
    # -- Frontend container image repository
    repository: private/nf-tower-enterprise/frontend
    # -- Specify a tag to override the version defined in .Chart.appVersion
    # @default -- `"{{ .chart.AppVersion }}-unprivileged"`
    tag: ""
    # -- Frontend container image digest in the format `sha256:1234abcdef`
    digest: ""

    # -- imagePullPolicy for the frontend container
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- List of imagePullSecrets
    # Secrets must be created in the same namespace, for example using the .extraDeploy array
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    pullSecrets: []
    # pullSecrets:
    #   - myRegistryKeySecretName

  service:
    # -- Frontend Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort
    type: ClusterIP
    http:
      # -- Service name to use
      name: http
      # -- Service port
      port: 80
      # -- Port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port)
      targetPort: 8083
      # -- (int) Service node port, only used when service.type is Nodeport or LoadBalancer
      # Choose port between 30000-32767, unless the cluster was configured differently than default
      nodePort: null

    # -- Other services that should live in the Service object
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    extraServices: []
    # extraServices:
    # - name: myspecialservice
    #   port: 1234
    #   targetPort: 5678
    #   nodePort: null

    # -- Extra Service options to place under .spec (for example, clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs). Evaluated as a template
    extraOptions: {}

  # -- Additional init containers for the frontend pod. Evaluated as a template
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the frontend pod. Evaluated as a template
  podLabels: {}
  # -- Additional annotations for the frontend pod. Evaluated as a template
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. revisionHistoryLimit, etc). Evaluated as a template.
  # Note: the cron deployment can only run a single replica and use Recreate strategy
  extraOptionsSpec: {}
  # extraOptionsSpec:
  #   replicas: 2
  #   strategy:
  #     rollingUpdate:
  #       maxUnavailable: x
  #       maxSurge: y

  # -- Extra options to place under .spec.template.spec (for example, nodeSelector, affinity,
  # restartPolicy). Evaluated as a template
  extraOptionsTemplateSpec: {}
  # extraOptionsTemplateSpec:
  #   nodeSelector:
  #     service: myspecialnodegroup

  # -- Extra environment variables to set on the frontend pod
  extraEnvVars: []
  # extraEnvVars:
  #   - name: "CUSTOM_ENV_VAR"
  #     value: "set-a-value-here"

  # -- ConfigMap containing extra env vars
  extraEnvVarsCMs: []
  # -- Secret containing extra env vars
  extraEnvVarsSecrets: []
  # -- Extra volumes to add to the deployment (evaluated as template). Requires setting
  # `extraVolumeMounts`
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # `extraVolumes`
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration
  podSecurityContext:
    # -- Enable pod Security Context
    enabled: true
    # -- GID that Kubernetes applies to mounted volumes and created files so processes
    # in the pod can share group-owned access
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable container Security Context
    enabled: true
    # -- UID the container processes run as (overrides container image default)
    runAsUser: 101
    # -- Require the container to run as a non-root UID (prevents starting if UID 0)
    runAsNonRoot: true
    # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container
    capabilities:
      drop:
        - ALL

  # -- Container requests and limits for different resources like CPU or memory
  resources: {}
  # `.requests` are the minimum CPU/memory resources the scheduler uses to place a pod;
  # the kubelet then guarantees at least these resources to the pod. `.limits` are the
  # maximum resources a container is allowed to use
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # Seqera recommends tuning resources to match the expected workload. The following are
  # sensible defaults to start with:
  #
  # resources:
  #   requests:
  #     cpu: "200m"
  #     memory: "200Mi"
  #   limits:
  #     memory: "200Mi"

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template
      port: "{{ .Values.frontend.service.http.targetPort }}"
    # -- Longer initial wait to accommodate slow-starting apps
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate
    # restarts)
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable
    # liveness/readiness
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template
      port: "{{ .Values.frontend.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart)
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template
      port: "{{ .Values.frontend.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container
    failureThreshold: 10
    # -- Typically 1 (usually ignored)
    successThreshold: 1

# Options specific to the Platform cron deployment
cron:
  image:
    # -- Cron container image registry
    registry: ""
    # -- Cron container image repository
    repository: private/nf-tower-enterprise/backend
    # -- Cron container image tag
    # @default -- `"{{ .chart.AppVersion }}"`
    tag: ""
    # -- Cron container image digest in the format `sha256:1234abcdef`
    digest: ""

    # -- imagePullPolicy for the cron container
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- List of imagePullSecrets
    # Secrets must be created in the same namespace, for example using the .extraDeploy array
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    pullSecrets: []
    # pullSecrets:
    #   - myRegistryKeySecretName

  # -- List of Micronaut Environments to enable on the cron pod
  micronautEnvironments: [prod, redis, cron]

  service:
    # -- Cron Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort
    type: ClusterIP
    http:
      # -- Service name to use
      name: http
      # -- Service port
      port: 8080
      # -- Port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port)
      targetPort: 8082
      # -- Service node port, only used when service.type is Nodeport or LoadBalancer
      # Choose port between 30000-32767, unless the cluster was configured differently than default
      nodePort: null

    # -- Other services that should live in the Service object
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    extraServices: []
    # extraServices:
    # - name: myspecialservice
    #   port: 1234
    #   targetPort: 5678
    #   nodePort: null

    # -- Extra Service options to place under .spec (for example, clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs). Evaluated as a template
    extraOptions: {}

  # -- Additional init containers for the cron pod. Evaluated as a template
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the cron pod. Evaluated as a template
  podLabels: {}
  # -- Additional annotations for the cron pod. Evaluated as a template
  podAnnotations: {}

  # -- Extra options to place under .spec (for example, revisionHistoryLimit). Evaluated as a template
  # Note that cron deployment needs to have a single replica with Recreate strategy
  extraOptionsSpec: {}
  # extraOptionsSpec:
  #   revisionHistoryLimit: 4

  # -- Extra options to place under .spec.template.spec (for example, nodeSelector, affinity, restartPolicy)
  # Evaluated as a template
  extraOptionsTemplateSpec: {}
  # extraOptionsTemplateSpec:
  #   nodeSelector:
  #     service: myspecialnodegroup

  # -- Extra environment variables to set on the cron pod
  extraEnvVars: []
  # extraEnvVars:
  #   - name: "CUSTOM_ENV_VAR"
  #     value: "set-a-value-here"

  # -- ConfigMap containing extra env vars
  extraEnvVarsCMs: []
  # -- Secret containing extra env vars
  extraEnvVarsSecrets: []
  # -- Extra volumes to add to the deployment (evaluated as template). Requires setting
  # `extraVolumeMounts`
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # `extraVolumes`
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration
  podSecurityContext:
    # -- Enable pod Security Context
    enabled: true
    # -- GID that Kubernetes applies to mounted volumes and created files so processes
    # in the pod can share group-owned access
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable container Security Context
    enabled: true
    # -- UID the container processes run as (overrides container image default)
    runAsUser: 101
    # -- Require the container to run as a non-root UID (prevents starting if UID 0)
    runAsNonRoot: true
    # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container
    capabilities:
      drop:
        - ALL

  # -- Container requests and limits for different resources like CPU or memory
  resources: {}
  # `.requests` are the minimum CPU/memory resources the scheduler uses to place a pod;
  # the kubelet then guarantees at least these resources to the pod. `.limits` are the
  # maximum resources a container is allowed to use
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # Seqera recommends tuning resources to match the expected workload. The following are
  # sensible defaults to start with:
  #
  # resources:
  #   requests:
  #     cpu: "1"
  #     memory: "4000Mi"
  #   limits:
  #     memory: "4000Mi"

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Longer initial wait to accommodate slow-starting apps
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate restarts)
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable liveness/readiness
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart)
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container
    failureThreshold: 10
    # -- Typically 1 (usually ignored)
    successThreshold: 1

  dbMigrationInitContainer:
    image:
      # -- Database migration container image registry
      registry: ""
      # -- Database migration container image repository
      repository: private/nf-tower-enterprise/migrate-db
      # -- Specify a tag to override the version defined in .Chart.appVersion
      # @default -- `"{{ .chart.AppVersion }}"`
      tag: ""
      # -- Database migration container image digest in the format `sha256:1234abcdef`
      digest: ""

      # -- imagePullPolicy for the database migration init container
      # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
      pullPolicy: IfNotPresent

      # -- List of imagePullSecrets
      # Secrets must be created in the same namespace, for example using the .extraDeploy array
      # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      pullSecrets: []
      # pullSecrets:
      #   - myRegistryKeySecretName

    # -- Override default container command (useful when using custom images)
    command: ["/bin/sh", "-c", "/migrate-db.sh"]
    # -- Override default container args (useful when using custom images)
    args: []

    # -- Extra environment variables to set on the cron pod
    extraEnvVars: []
    # extraEnvVars:
    #   - name: "CUSTOM_ENV_VAR"
    #     value: "set-a-value-here"

    # -- ConfigMap containing extra env vars
    extraEnvVarsCMs: []
    # -- Secret containing extra env vars
    extraEnvVarsSecrets: []
    # -- Extra volumes to add to the deployment (evaluated as template). Requires setting
    # `extraVolumeMounts`
    extraVolumes: []
    # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
    # `extraVolumes`
    extraVolumeMounts: []

    # Configure Init Container Security Context
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      # -- Enable container Security Context
      enabled: true
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources: {}
    # `.requests` are the minimum CPU/memory resources the scheduler uses to place a pod;
    # the kubelet then guarantees at least these resources to the pod. `.limits` are the
    # maximum resources a container is allowed to use
    # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    # Seqera recommends tuning resources to match the expected workload. The following are
    # sensible defaults to start with:
    #
    # resources:
    #   requests:
    #     cpu: "1"
    #     memory: "4000Mi"
    #   limits:
    #     memory: "4000Mi"

initContainerDependencies:
  # -- Enable init containers that coordinate startup dependencies between Platform components
  # (for example, wait for database readiness before cron starts, wait for cron before backend
  # starts, etc)
  enabled: true

  waitForMySQL:
    # -- Enable wait for MySQL init container before starting backend and cron
    enabled: true
    image:
      # -- Override default wait for MySQL init container image
      registry: ""
      repository: "mysql"
      tag: "9"
      # Digest must be in the format `sha256:1234abcdef`
      digest: ""
      pullPolicy: IfNotPresent

    securityContext:
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID
      # 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources:
      requests:
        cpu: "0.5"
        memory: "50Mi"
      limits:
        memory: "100Mi"

  waitForRedis:
    # -- Enable wait for Redis init container before starting backend and cron
    enabled: true
    image:
      # -- Override default wait for Redis init container image
      registry: ""
      repository: "redis"
      tag: "7"
      # Digest must be in the format `sha256:1234abcdef`
      digest: ""
      pullPolicy: IfNotPresent

    securityContext:
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID
      # 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources:
      requests:
        cpu: "0.5"
        memory: "50Mi"
      limits:
        memory: "100Mi"

  waitForCron:
    # -- Enable wait for Platform cron init container before starting backend
    enabled: true
    image:
      # -- Override default wait for cron init container image
      registry: ""
      repository: "curlimages/curl"
      tag: "latest"
      # Digest must be in the format `sha256:1234abcdef`
      digest: ""
      pullPolicy: IfNotPresent

    securityContext:
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID
      # 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources:
      requests:
        cpu: "0.5"
        memory: "50Mi"
      limits:
        memory: "100Mi"

serviceAccount:
  # -- Name of an existing ServiceAccount. If not set, a new ServiceAccount is generated based on
  # the release name
  name: ""
  # -- Additional annotations for the Platform ServiceAccount to generate
  annotations: {}
  # -- Names of Secrets containing credentials to pull images from registries
  imagePullSecretNames: []
  # -- Automount service account token when the server service account is generated
  automountServiceAccountToken: false

ingress:
  # -- Enable ingress for Platform
  enabled: false

  # -- Path for the main ingress rule
  # Note: this needs to be set to '/*' to be used with AWS ALB ingress controller
  path: "/"

  # -- Path for the content domain ingress rule
  # Note: this needs to be set to '/*' to be used with AWS ALB ingress controller
  contentPath: "/"

  # -- Default path type for the Ingress
  defaultPathType: "ImplementationSpecific"

  # -- Configure the default service for the ingress (evaluated as template)
  # Important: make sure only one defaultBackend is defined across the k8s cluster: if the
  # ingress doesn't reconcile successfully, 'describe ingress <name>' will report problems
  defaultBackend: {}
  # defaultBackend:
  #   service:
  #     name: '{{ printf "%s-frontend" (include "common.names.fullname" .) }}'
  #     port:
  #       number: '{{ .Values.frontend.service.http.port }}'

  # -- Additional hosts you want to include. Evaluated as a template
  extraHosts: []
  # extraHosts:
  #   - host: '{{ printf "api.%s" .Values.global.platformExternalDomain }}'
  #     paths:
  #       - path: /*
  #         pathType: Prefix  # Optional, defaults to defaultPathType
  #         serviceName: '{{ printf "%s-backend" (include "common.names.fullname" .) }}'
  #         portNumber: '{{ .Values.global.platformServicePort }}'
  #   - host: '{{ printf "www.%s" .Values.global.platformExternalDomain }}'
  #     paths:
  #       - path: /*
  #         pathType: Prefix  # Optional, defaults to defaultPathType
  #         serviceName: '{{ printf "%s-frontend" (include "common.names.fullname" .) }}'
  #         portNumber: '{{ .Values.frontend.service.http.port }}'

  # -- Ingress annotations specific to your load balancer. Evaluated as a template
  annotations: {}
  # -- Additional labels for the ingress object. Evaluated as a template
  extraLabels: {}
  # -- Name of the ingress class (replaces the deprecated annotation `kubernetes.io/ingress.class`)
  ingressClassName: ""
  # -- TLS configuration. Evaluated as a template
  tls: []
  # tls:
  #   - hosts:
  #       - '{{ .Values.global.platformExternalDomain }}'
  #       - '{{ printf "user-data.%s" .Values.global.platformExternalDomain }}'
  #     secretName: my-tls

# -- Array of extra objects to deploy with the release
extraDeploy: []
# extraDeploy:
#   - apiVersion: v1
#     kind: MyExtraObjectKind
#     ...
#   - apiVersion: v1
#     kind: AnotherExtraObjectKind
#     ...

# -- Annotations to add to all deployed objects
commonAnnotations: {}
# -- Labels to add to all deployed objects
commonLabels: {}

studios:
  # -- Enable Studios feature. Refer to the subchart README for more details and the full list of
  # configuration options
  enabled: true

pipeline-optimization:
  # -- Enable pipeline optimization feature. Refer to the subchart README for more details and the
  # full list of configuration options
  enabled: true
