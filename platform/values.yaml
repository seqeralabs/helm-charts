# Copyright (c) 2025 - 2026 Seqera Labs
# All rights reserved.
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# This values.yaml file contains the default values for the Seqera Platform Helm chart.
# Users can override these values by providing their own values.yaml file or by using --set flags
# during Helm installation or upgrade. Refer to the README.md file for more instructions on the most
# important values to set and more details on the product. The README.md file also contains a table
# view of all the available configuration options detailed in this values.yaml file. We recommend
# copying the content of this values.yaml file to an empty file, remove the values you don't need to
# change, and set the desired values for your deployment.
#
# More charts are stored under the charts/ directory and each of them comes with its own values.yaml
# file. The subcharts are designed to be used alongside this main Platform chart, but they can also
# be used independently if desired. To configure the subcharts as part of the Platform deployment,
# refer to the respective values.yaml files and check the condition field in the Chart.yaml file to
# see how to enable/disable them and how to nest their values.

# Values in the .global section can be accessed by both parent and child subcharts as
# .Values.global.*: https://helm.sh/docs/chart_template_guide/subcharts_and_globals/
global:
  # -- Domain where Seqera Platform listens
  platformExternalDomain: example.com

  # -- Domain where user-created Platform reports are exposed, to avoid Cross-Site Scripting (XSS)
  # attacks. If unset, data is served through the main domain
  # <code>.global.platformExternalDomain</code>. Evaluated as a template
  contentDomain: '{{ printf "user-data.%s" .Values.global.platformExternalDomain }}'

  # -- Seqera Platform Service name: can be the internal Kubernetes hostname or an external ingress
  # hostname. Evaluated as a template
  platformServiceAddress: '{{ printf "%s-backend" (include "common.names.fullname" .) }}'
  # -- Seqera Platform Service port
  platformServicePort: 8080

  # -- Optional credentials to log in and fetch images from a private registry. These credentials
  # are shared with all the subcharts automatically
  #
  # <pre><code>
  # - registry: ""</br>
  #   username: ""</br>
  #   password: ""</br>
  #   email: someone@example.com  # Optional
  # </code></pre>
  imageCredentials: []

platformDatabase:
  # -- Platform MySQL database hostname
  host: ""
  # -- Platform MySQL database port
  port: 3306
  # -- Platform MySQL database name
  name: ""
  # -- Platform MySQL database username
  username: ""
  # -- Platform MySQL database password
  password: ""
  # -- Name of an existing secret containing credentials for the Platform MySQL database.
  # Note: the secret must already exist in the same namespace at the time of deployment, it
  # can't be created by this chart with extraDeploy, since this chart performs a lookup
  # on the Kubernetes API server at install/upgrade time
  existingSecretName: ""
  # -- Key in the existing secret containing the password for the Platform MySQL database
  # @default -- "TOWER_DB_PASSWORD"
  existingSecretKey: ""
  # -- Database driver. Possible options: "mariadb" (or its alias "mysql")
  driver: "mariadb"
  # -- Connection options to compose in the driver URL according to the driver used. The only
  # driver that can be set is 'mariadb'
  connectionOptions:
    # -- Connection options to use with the MariaDB driver. For the full list of supported
    # options see:
    # https://mariadb.com/docs/connectors/mariadb-connector-j/about-mariadb-connector-j
    mariadb:
      # permitMysqlScheme=true allows the MariaDB driver to communicate with MySQL databases.
      - permitMysqlScheme=true
      # sslMode enables TLS encryption with varying levels of certificate acceptance criteria.
      # Other options allow the enabling or disabling of specific TLS ciphers, the path to the
      # server's CA certificate, etc.
      # - sslMode=verify-ca
  # -- Hibernate dialect to use, depending on the database version. Possible options: mysql-8
  # (default), mariadb-10
  dialect: "mysql-8"
  # -- Connection pool minimum size
  minPoolSize: "2"
  # -- Connection pool maximum size
  maxPoolSize: "10"
  # -- Connection pool maximum lifetime
  maxLifetime: "180000"

platform:
  # TODO: rename variable?
  # -- Content to insert into the tower.yml file (you can use <code>\|-</code> YAML multilines). See
  # https://docs.seqera.io/platform-enterprise/enterprise/configuration/overview
  YAMLConfigFileContent: ""

  # -- Sender email address for user support
  contactEmail: support@example.com

  # -- JWT seed, defined as string, used to sign authentication tokens
  # Define the value as a String or a Secret, not both at the same time
  # If neither is defined, Helm generates a random 35-character string
  jwtSeedString: ""
  # -- Name of an existing Secret containing the JWT seed. Note: the secret must already exist in
  # the same namespace at the time of deployment, it can't be created by this chart with
  # extraDeploy, since this chart performs a lookup on the Kubernetes API server at
  # install/upgrade time
  jwtSeedSecretName: ""
  # -- Key in the existing secret containing the JWT seed
  # @default -- "TOWER_JWT_SECRET"
  jwtSeedSecretKey: ""

  # -- Crypto seed, defined as string, used to encrypt sensitive data in the database.
  # Note: this needs to be a stable value that doesn't change between deployments, otherwise
  # encrypted data in the database will become inaccessible.
  # Either define the value as a String or a Secret, not both at the same time.
  # If neither is defined, a random 35 characters long string will be generated by Helm
  cryptoSeedString: ""
  # -- Name of an existing Secret containing the crypto seed. Note: the secret must already exist in
  # the same namespace at the time of deployment, it can't be created by this chart with
  # extraDeploy, since this chart performs a lookup on the Kubernetes API server at
  # install/upgrade time
  cryptoSeedSecretName: ""
  # -- Key in the existing secret containing the crypto seed
  # @default -- "TOWER_CRYPTO_SECRETKEY"
  cryptoSeedSecretKey: ""

  # -- List of execution backends to enable. At least one is required. See
  # https://docs.seqera.io/platform-enterprise/enterprise/configuration/overview#compute-environments
  executionBackends:
    - altair-platform
    - awsbatch-platform
    - awscloud-platform
    - azbatch-platform
    - azcloud-platform
    - eks-platform
    - gke-platform
    - googlebatch-platform
    - googlecloud-platform
    - k8s-platform
    - local-platform
    - lsf-platform
    - moab-platform
    - slurm-platform

  # -- Platform license key. A license key is a long alphanumeric string provided by your Seqera
  # account manager
  # Define the value as a String or a Secret, not both at the same time
  licenseString: ""
  # -- Name of an existing Secret containing the Platform license key. Note: the secret must already
  # exist in the same namespace at the time of deployment, it can't be created by this chart with
  # extraDeploy, since this chart performs a lookup on the Kubernetes API server at
  # install/upgrade time
  licenseSecretName: ""
  # -- Key in the existing secret containing the Platform license key
  # @default -- "TOWER_LICENSE"
  licenseSecretKey: ""

  smtp:
    # -- SMTP server hostname to let users authenticate through email, and to send email
    # notifications for events
    host: ""
    # -- SMTP server port
    port: ""
    # -- SMTP server username
    user: ""
    # -- SMTP server password
    password: ""
    # -- Name of an existing secret containing the SMTP password
    existingSecretName: ""
    # -- Key in the existing secret containing the SMTP password
    # @default -- "TOWER_SMTP_PASSWORD"
    existingSecretKey: ""

  # -- URL of the Wave service Platform uses. Evaluated as a template.
  # The Wave service provided by Seqera is <code>https://wave.seqera.io</code>
  waveServerUrl: "https://wave.seqera.io"

  # -- Additional labels for the ConfigMap objects. Evaluated as a template
  configMapLabels: {}
  # -- Additional labels for the Secret objects. Evaluated as a template
  secretLabels: {}
  # -- Additional labels for the Service objects. Evaluated as a template
  serviceLabels: {}
  # -- Additional annotations for the ConfigMap objects. Evaluated as a template
  configMapAnnotations: {}
  # -- Additional annotations for the Secret objects. Evaluated as a template
  secretAnnotations: {}
  # -- Additional annotations for the Service objects. Evaluated as a template
  serviceAnnotations: {}

# Note that Platform currently doesn't support specifying a Redis database within a Redis instance
redis:
  # -- Redis hostname
  host: ""
  # -- Redis port
  port: 6379
  # -- Redis password if the installation requires it
  password: ""
  # -- Name of an existing secret containing credentials for Redis, as an alternative to the
  # password field. Note: the secret must already exist in the same namespace at the time of
  # deployment, it can't be created by this chart with extraDeploy, since this chart performs a
  # lookup on the Kubernetes API server at install/upgrade time
  existingSecretName: ""
  # -- Key in the existing secret containing the password for Redis
  # @default -- "TOWER_REDIS_PASSWORD"
  existingSecretKey: ""
  # -- Enable TLS when connecting to Redis
  enableTls: false

# -- Array of extra objects to deploy with the release
#
# <pre><code>
# extraDeploy:<br>
#   - apiVersion: v1<br>
#     kind: MyExtraObjectKind<br>
#     ...<br>
#   - apiVersion: v1<br>
#     kind: AnotherExtraObjectKind<br>
#     ...
# </code></pre>
extraDeploy: []

# -- Annotations to add to all deployed objects
commonAnnotations: {}
# -- Labels to add to all deployed objects
commonLabels: {}

# Options specific to the Platform backend deployment
backend:
  image:
    # -- Backend container image registry
    registry: ""
    # -- Backend container image repository
    repository: private/nf-tower-enterprise/backend
    # -- Backend container image tag
    # @default -- "{{ .chart.AppVersion }}"
    tag: ""
    # -- Backend container image digest in the format <code>sha256:1234abcdef</code>
    digest: ""

    # -- imagePullPolicy for the backend container
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- List of imagePullSecrets
    # Secrets must be created in the same namespace, for example using the .extraDeploy array
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    #
    # <pre><code>
    # pullSecrets:<br>
    #   - myRegistryKeySecretName
    # </code></pre>
    pullSecrets: []

  # -- List of Micronaut Environments to enable on the backend pod
  micronautEnvironments: [prod, redis, ha]

  service:
    # -- Backend Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort
    type: ClusterIP
    http:
      # -- Service name to use
      name: http
      # The external port is defined as the global variable
      # <code>.global.platformServicePort</code>, so it can be used by subcharts too

      # -- Port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port). Platform v25.3+ only; previous
      # versions were hardcoded to 8080
      targetPort: 8080
      # -- Service node port, only used when service.type is Nodeport or LoadBalancer
      # Choose port between 30000-32767, unless the cluster was configured differently than default
      nodePort: null
    # -- Other services that should live in the Service object
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #
    # <pre><code>
    # extraServices:<br>
    # - name: myspecialservice<br>
    #   port: 1234<br>
    #   targetPort: 5678<br>
    #   nodePort: null
    # </code></pre>
    extraServices: []
    # -- Extra Service options to place under .spec (for example, clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs). Evaluated as a template
    extraOptions: {}

  # -- Additional init containers for the backend pod. Evaluated as a template
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the backend pod. Evaluated as a template
  podLabels: {}
  # -- Additional annotations for the backend pod. Evaluated as a template
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. replicas, strategy, revisionHistoryLimit, etc).
  # Evaluated as a template
  #
  # <pre><code>
  # extraOptionsSpec:<br>
  #   replicas: 2<br>
  #   strategy:<br>
  #     rollingUpdate:<br>
  #       maxUnavailable: x<br>
  #       maxSurge: y
  # </code></pre>
  extraOptionsSpec:
    replicas: 3
  # -- Extra options to place under .spec.template.spec (e.g. nodeSelector, affinity, restartPolicy,
  # etc). Evaluated as a template
  #
  # <pre><code>
  # extraOptionsTemplateSpec:<br>
  #   nodeSelector:<br>
  #     service: myspecialnodegroup
  # </code></pre>
  extraOptionsTemplateSpec: {}

  # -- Extra environment variables to set on the backend pod
  #
  # <pre><code>
  # extraEnvVars:<br>
  #   - name: "CUSTOM_ENV_VAR"<br>
  #     value: "set-a-value-here"
  # </code></pre>
  extraEnvVars: []
  # -- ConfigMap containing extra env vars
  extraEnvVarsCMs: []
  # -- Secret containing extra env vars
  extraEnvVarsSecrets: []
  # -- Extra volumes to be added to the deployment (evaluated as template). Requires setting
  # <code>extraVolumeMounts</code>
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # <code>extraVolumes</code>
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration
  podSecurityContext:
    # -- Enable pod Security Context
    enabled: true
    # -- Sets the GID that Kubernetes will apply to mounted volumes and created files so processes
    # in the pod can share group-owned access
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable container Security Context
    enabled: true
    # -- UID the container processes run as (overrides container image default)
    runAsUser: 101
    # -- Boolean that requires the container to run as a non-root UID (prevents starting if UID 0)
    runAsNonRoot: true
    # -- Mounts the container root filesystem read-only to prevent in-place writes or tampering
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container
    capabilities:
      drop:
        - ALL

  # -- Container requests and limits for different resources like CPU or memory
  # <code>.requests</code> are the minimum CPU/memory resources the scheduler uses to place a pod;
  # the kubelet then guarantees at least these resources to the pod. <code>.limits</code> are the
  # maximum resources a container is allowed to use
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # Seqera recommends configuring resources to match the expected workload. The following are
  # sensible defaults to start with
  #
  # <pre><code>
  # resources:<br>
  #   requests:<br>
  #     cpu: "1"<br>
  #     memory: "4000Mi"<br>
  #   limits:<br>
  #     memory: "4000Mi"
  # </code></pre>
  resources: {}

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template. Note: before v25.3 this was
      # hardcoded to 8080
      port: '{{ .Values.backend.service.http.targetPort }}'
    # -- Longer initial wait to accommodate slow-starting apps
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate
    # restarts)
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable
    # liveness/readiness
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template. Note: before v25.3 this was
      # hardcoded to 8080
      port: '{{ .Values.backend.service.http.targetPort }}'
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart)
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template. Note: before v25.3 this was
      # hardcoded to 8080
      port: '{{ .Values.backend.service.http.targetPort }}'
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container
    failureThreshold: 10
    # -- Typically 1 (usually ignored)
    successThreshold: 1

# Options specific to the Platform frontend deployment
frontend:
  image:
    # -- Frontend container image registry
    registry: ""
    # -- Frontend container image repository
    repository: private/nf-tower-enterprise/frontend
    # -- Specify a tag to override the version defined in .Chart.appVersion
    # @default -- "{{ .chart.AppVersion }}-unprivileged"
    tag: ""
    # -- Frontend container image digest in the format <code>sha256:1234abcdef</code>
    digest: ""

    # -- imagePullPolicy for the frontend container
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- List of imagePullSecrets
    # Secrets must be created in the same namespace, for example using the .extraDeploy array
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    #
    # <pre><code>
    # pullSecrets:<br>
    #   - myRegistryKeySecretName
    # </code></pre>
    pullSecrets: []

  service:
    # -- Frontend Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort
    type: ClusterIP
    http:
      # -- Service name to use
      name: http
      # -- Service port
      port: 80
      # -- Port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port)
      targetPort: 8083
      # -- (int) Service node port, only used when service.type is Nodeport or LoadBalancer
      # Choose port between 30000-32767, unless the cluster was configured differently than default
      nodePort: null
    # -- Other services that should live in the Service object
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #
    # <pre><code>
    # extraServices:<br>
    # - name: myspecialservice<br>
    #   port: 1234<br>
    #   targetPort: 5678<br>
    #   nodePort: null
    # </code></pre>
    extraServices: []
    # -- Extra Service options to place under .spec (for example, clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs). Evaluated as a template
    extraOptions: {}

  # -- Additional init containers for the frontend pod. Evaluated as a template
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the frontend pod. Evaluated as a template
  podLabels: {}
  # -- Additional annotations for the frontend pod. Evaluated as a template
  podAnnotations: {}

  # -- Extra options to place under .spec (e.g. revisionHistoryLimit, etc). Evaluated as a template.
  # Note: the cron deployment can only run a single replica and use Recreate strategy
  #
  # <pre><code>
  # extraOptionsSpec:<br>
  #   replicas: 2<br>
  #   strategy:<br>
  #     rollingUpdate:<br>
  #       maxUnavailable: x<br>
  #       maxSurge: y
  # </code></pre>
  extraOptionsSpec: {}
  # -- Extra options to place under .spec.template.spec (for example, nodeSelector, affinity,
  # restartPolicy). Evaluated as a template
  #
  # <pre><code>
  # extraOptionsTemplateSpec:<br>
  #   nodeSelector:<br>
  #     service: myspecialnodegroup
  # </code></pre>
  extraOptionsTemplateSpec: {}

  # -- Extra environment variables to set on the frontend pod
  #
  # <pre><code>
  # extraEnvVars:<br>
  #   - name: "CUSTOM_ENV_VAR"<br>
  #     value: "set-a-value-here"
  # </code></pre>
  extraEnvVars: []
  # -- ConfigMap containing extra env vars
  extraEnvVarsCMs: []
  # -- Secret containing extra env vars
  extraEnvVarsSecrets: []
  # -- Extra volumes to add to the deployment (evaluated as template). Requires setting
  # <code>extraVolumeMounts</code>
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # <code>extraVolumes</code>
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration
  podSecurityContext:
    # -- Enable pod Security Context
    enabled: true
    # -- GID that Kubernetes applies to mounted volumes and created files so processes
    # in the pod can share group-owned access
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable container Security Context
    enabled: true
    # -- UID the container processes run as (overrides container image default)
    runAsUser: 101
    # -- Require the container to run as a non-root UID (prevents starting if UID 0)
    runAsNonRoot: true
    # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container
    capabilities:
      drop:
        - ALL

  # -- Container requests and limits for different resources like CPU or memory
  # <code>.requests</code> are the minimum CPU/memory resources the scheduler uses to place a pod;
  # the kubelet then guarantees at least these resources to the pod. <code>.limits</code> are the
  # maximum resources a container is allowed to use
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # Seqera recommends configuring resources to match the expected workload. The following are
  # sensible defaults to start with
  #
  # <pre><code>
  # resources:<br>
  #   requests:<br>
  #     cpu: "200m"<br>
  #     memory: "200Mi"<br>
  #   limits:<br>
  #     memory: "200Mi"
  # </code></pre>
  resources: {}

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template
      port: "{{ .Values.frontend.service.http.targetPort }}"
    # -- Longer initial wait to accommodate slow-starting apps
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate
    # restarts)
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable
    # liveness/readiness
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template
      port: "{{ .Values.frontend.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart)
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template
      port: "{{ .Values.frontend.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container
    failureThreshold: 10
    # -- Typically 1 (usually ignored)
    successThreshold: 1

# Options specific to the Platform cron deployment
cron:
  image:
    # -- Cron container image registry
    registry: ""
    # -- Cron container image repository
    repository: private/nf-tower-enterprise/backend
    # -- Cron container image tag
    # @default -- "{{ .chart.AppVersion }}"
    tag: ""
    # -- Cron container image digest in the format <code>sha256:1234abcdef</code>
    digest: ""

    # -- imagePullPolicy for the cron container
    # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
    pullPolicy: IfNotPresent

    # -- List of imagePullSecrets
    # Secrets must be created in the same namespace, for example using the .extraDeploy array
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
    #
    # <pre><code>
    # pullSecrets:<br>
    #   - myRegistryKeySecretName
    # </code></pre>
    pullSecrets: []

  # -- List of Micronaut Environments to enable on the cron pod
  micronautEnvironments: [prod, redis, cron]

  service:
    # -- Cron Service type.
    # Note: ingresses using AWS ALB require the service to be NodePort
    type: ClusterIP
    http:
      # -- Service name to use
      name: http
      # -- Service port
      port: 8080
      # -- Port on the pod/container that the Service forwards traffic to (can be a number or
      # named port, distinct from the Service's external port)
      targetPort: 8082
      # -- Service node port, only used when service.type is Nodeport or LoadBalancer
      # Choose port between 30000-32767, unless the cluster was configured differently than default
      nodePort: null
    # -- Other services that should live in the Service object
    # https://kubernetes.io/docs/concepts/services-networking/service/#defining-a-service
    #
    # <pre><code>
    # extraServices:<br>
    # - name: myspecialservice<br>
    #   port: 1234<br>
    #   targetPort: 5678<br>
    #   nodePort: null
    # </code></pre>
    extraServices: []
    # -- Extra Service options to place under .spec (for example, clusterIP, loadBalancerIP,
    # externalTrafficPolicy, externalIPs). Evaluated as a template
    extraOptions: {}

  # -- Additional init containers for the cron pod. Evaluated as a template
  initContainers: []

  # -- Override default container command (useful when using custom images)
  command: []
  # -- Override default container args (useful when using custom images)
  args: []

  # -- Additional labels for the cron pod. Evaluated as a template
  podLabels: {}
  # -- Additional annotations for the cron pod. Evaluated as a template
  podAnnotations: {}

  # -- Extra options to place under .spec (for example, revisionHistoryLimit). Evaluated as a template
  # Note that cron deployment needs to have a single replica with Recreate strategy
  #
  # <pre><code>
  # extraOptionsSpec:<br>
  #   revisionHistoryLimit: 4
  # </code></pre>
  extraOptionsSpec: {}
  # -- Extra options to place under .spec.template.spec (for example, nodeSelector, affinity, restartPolicy)
  # Evaluated as a template
  #
  # <pre><code>
  # extraOptionsTemplateSpec:<br>
  #   nodeSelector:<br>
  #     service: myspecialnodegroup
  # </code></pre>
  extraOptionsTemplateSpec: {}

  # -- Extra environment variables to set on the cron pod
  #
  # <pre><code>
  # extraEnvVars:<br>
  #   - name: "CUSTOM_ENV_VAR"<br>
  #     value: "set-a-value-here"
  # </code></pre>
  extraEnvVars: []
  # -- ConfigMap containing extra env vars
  extraEnvVarsCMs: []
  # -- Secret containing extra env vars
  extraEnvVarsSecrets: []
  # -- Extra volumes to add to the deployment (evaluated as template). Requires setting
  # <code>extraVolumeMounts</code>
  extraVolumes: []
  # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
  # <code>extraVolumes</code>
  extraVolumeMounts: []

  # Configure Pods Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-pod
  # Empty map to disable Pod Security Context configuration
  podSecurityContext:
    # -- Enable pod Security Context
    enabled: true
    # -- GID that Kubernetes applies to mounted volumes and created files so processes
    # in the pod can share group-owned access
    fsGroup: 101

  # Configure Container Security Context.
  # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
  containerSecurityContext:
    # -- Enable container Security Context
    enabled: true
    # -- UID the container processes run as (overrides container image default)
    runAsUser: 101
    # -- Require the container to run as a non-root UID (prevents starting if UID 0)
    runAsNonRoot: true
    # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
    readOnlyRootFilesystem: true
    # -- Fine-grained Linux kernel privileges to add or drop for the container
    capabilities:
      drop:
        - ALL

  # -- Container requests and limits for different resources like CPU or memory
  # <code>.requests</code> are the minimum CPU/memory resources the scheduler uses to place a pod;
  # the kubelet then guarantees at least these resources to the pod. <code>.limits</code> are the
  # maximum resources a container is allowed to use
  # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
  # Seqera recommends configuring resources to match the expected workload. The following are
  # sensible defaults to start with
  #
  # <pre><code>
  # resources:<br>
  #   requests:<br>
  #     cpu: "1"<br>
  #     memory: "4000Mi"<br>
  #   limits:<br>
  #     memory: "4000Mi"
  # </code></pre>
  resources: {}

  # Configure extra options for the startup probe
  startupProbe:
    # -- Enable startup probe
    enabled: false
    httpGet:
      # -- HTTP GET path for startup probe
      path: "/health"
      # -- HTTP GET port for startup probe. Evaluated as a template
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Longer initial wait to accommodate slow-starting apps
    initialDelaySeconds: 5
    # -- Often set longer to avoid frequent checks while starting
    periodSeconds: 10
    # -- Can be longer to allow slow initialization responses
    timeoutSeconds: 3
    # -- Consecutive failures during startup before killing the container (instead of immediate restarts)
    failureThreshold: 5
    # -- Number of consecutive successes required to consider startup complete and enable liveness/readiness
    successThreshold: 1

  # Configure extra options for the readiness probe
  readinessProbe:
    # -- Enable readiness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for readiness probe
      path: "/health"
      # -- HTTP GET port for readiness probe. Evaluated as a template
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 5
    # -- Short timeout to detect unresponsive containers for readiness
    timeoutSeconds: 3
    # -- Consecutive failures before marking the container Unready (no restart)
    failureThreshold: 5
    # -- Number of consecutive successes required to mark the container Ready after failures
    successThreshold: 1

  # Configure extra options for the liveness probe
  livenessProbe:
    # -- Enable liveness probe
    enabled: true
    httpGet:
      # -- HTTP GET path for liveness probe
      path: "/health"
      # -- HTTP GET port for liveness probe. Evaluated as a template
      port: "{{ .Values.cron.service.http.targetPort }}"
    # -- Delay before first check (normal start timing)
    initialDelaySeconds: 5
    # -- Regular check interval during normal operation
    periodSeconds: 10
    # -- Short timeout to detect hung containers quickly
    timeoutSeconds: 3
    # -- Consecutive failures before restarting the container
    failureThreshold: 10
    # -- Typically 1 (usually ignored)
    successThreshold: 1

  dbMigrationInitContainer:
    image:
      # -- Database migration container image registry
      registry: ""
      # -- Database migration container image repository
      repository: private/nf-tower-enterprise/migrate-db
      # -- Specify a tag to override the version defined in .Chart.appVersion
      # @default -- "{{ .chart.AppVersion }}"
      tag: ""
      # -- Database migration container image digest in the format <code>sha256:1234abcdef</code>
      digest: ""

      # -- imagePullPolicy for the database migration init container
      # Ref: https://kubernetes.io/docs/concepts/containers/images/#pre-pulled-images
      pullPolicy: IfNotPresent

      # -- List of imagePullSecrets
      # Secrets must be created in the same namespace, for example using the .extraDeploy array
      # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/pull-image-private-registry/
      #
      # <pre><code>
      # pullSecrets:<br>
      #   - myRegistryKeySecretName
      # </code></pre>
      pullSecrets: []

    # -- Override default container command (useful when using custom images)
    command: ["/bin/sh", "-c", "/migrate-db.sh"]
    # -- Override default container args (useful when using custom images)
    args: []

    # -- Extra environment variables to set on the cron pod
    #
    # <pre><code>
    # extraEnvVars:<br>
    #   - name: "CUSTOM_ENV_VAR"<br>
    #     value: "set-a-value-here"
    # </code></pre>
    extraEnvVars: []
    # -- ConfigMap containing extra env vars
    extraEnvVarsCMs: []
    # -- Secret containing extra env vars
    extraEnvVarsSecrets: []
    # -- Extra volumes to add to the deployment (evaluated as template). Requires setting
    # <code>extraVolumeMounts</code>
    extraVolumes: []
    # -- Extra volume mounts to add to the container (evaluated as template). Normally used with
    # <code>extraVolumes</code>
    extraVolumeMounts: []

    # Configure Init Container Security Context
    # Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/#set-the-security-context-for-a-container
    containerSecurityContext:
      # -- Enable container Security Context
      enabled: true
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    # <code>.requests</code> are the minimum CPU/memory resources the scheduler uses to place a pod;
    # the kubelet then guarantees at least these resources to the pod. <code>.limits</code> are the
    # maximum resources a container is allowed to use
    # Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    # Seqera recommends configuring resources to match the expected workload. The following are
    # sensible defaults to start with
    #
    # <pre><code>
    # resources:<br>
    #   requests:<br>
    #     cpu: "1"<br>
    #     memory: "4000Mi"<br>
    #   limits:<br>
    #     memory: "4000Mi"
    # </code></pre>
    resources: {}

initContainerDependencies:
  # -- Enable init containers that coordinate startup dependencies between Platform components
  # (for example, wait for database readiness before cron starts, wait for cron before backend
  # starts, etc)
  enabled: true

  waitForMySQL:
    # -- Enable wait for MySQL init container before starting backend and cron
    enabled: true
    image:
      # -- Override default wait for MySQL init container image
      registry: ""
      repository: "mysql"
      tag: "9"
      # Digest must be in the format <code>sha256:1234abcdef</code>
      digest: ""
      pullPolicy: IfNotPresent

    securityContext:
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID
      # 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources:
      requests:
        cpu: "0.5"
        memory: "50Mi"
      limits:
        memory: "100Mi"

  waitForRedis:
    # -- Enable wait for Redis init container before starting backend and cron
    enabled: true
    image:
      # -- Override default wait for Redis init container image
      registry: ""
      repository: "redis"
      tag: "7"
      # Digest must be in the format <code>sha256:1234abcdef</code>
      digest: ""
      pullPolicy: IfNotPresent

    securityContext:
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID
      # 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources:
      requests:
        cpu: "0.5"
        memory: "50Mi"
      limits:
        memory: "100Mi"

  waitForCron:
    # -- Enable wait for Platform cron init container before starting backend
    enabled: true
    image:
      # -- Override default wait for cron init container image
      registry: ""
      repository: "curlimages/curl"
      tag: "latest"
      # Digest must be in the format <code>sha256:1234abcdef</code>
      digest: ""
      pullPolicy: IfNotPresent

    securityContext:
      # -- UID the container processes run as (overrides container image default)
      runAsUser: 101
      # -- Require the container to run as a non-root UID (prevents starting if UID
      # 0)
      runAsNonRoot: true
      # -- Mount the container root filesystem read-only to prevent in-place writes or tampering
      readOnlyRootFilesystem: true
      # -- Fine-grained Linux kernel privileges to add or drop for the container
      capabilities:
        drop:
          - ALL

    # -- Container requests and limits for different resources like CPU or memory
    resources:
      requests:
        cpu: "0.5"
        memory: "50Mi"
      limits:
        memory: "100Mi"

serviceAccount:
  # -- Name of an existing ServiceAccount. If not set, a new ServiceAccount is generated based on
  # the release name
  name: ""
  # -- Additional annotations for the Platform ServiceAccount to generate
  annotations: {}
  # -- Names of Secrets containing credentials to pull images from registries
  imagePullSecretNames: []
  # -- Automount service account token when the server service account is generated
  automountServiceAccountToken: false

ingress:
  # -- Enable ingress for Platform
  enabled: false

  # -- Path for the main ingress rule
  # Note: this needs to be set to '/*' to be used with AWS ALB ingress controller
  path: "/"

  # -- Path for the content domain ingress rule
  # Note: this needs to be set to '/*' to be used with AWS ALB ingress controller
  contentPath: "/"

  # -- Default path type for the Ingress
  defaultPathType: "ImplementationSpecific"

  # -- Configure the default service for the ingress (evaluated as template)
  # Important: make sure only one defaultBackend is defined across the k8s cluster: if the
  # ingress doesn't reconcile successfully, 'describe ingress <name>' will report problems
  #
  # <pre><code>
  # defaultBackend:<br>
  #   service:<br>
  #     name: '{{ printf "%s-frontend" (include "common.names.fullname" .) }}'<br>
  #     port:<br>
  #       number: '{{ .Values.frontend.service.http.port }}'
  # </code></pre>
  defaultBackend: {}

  # -- Additional hosts you want to include. Evaluated as a template
  #
  # <pre><code>
  # extraHosts:<br>
  #   - host: '{{ printf "api.%s" .Values.global.platformExternalDomain }}'<br>
  #     paths:<br>
  #       - path: /*<br>
  #         pathType: Prefix  # Optional, defaults to defaultPathType<br>
  #         serviceName: '{{ printf "%s-backend" (include "common.names.fullname" .) }}'<br>
  #         portNumber: '{{ .Values.global.platformServicePort }}'<br>
  #   - host: '{{ printf "www.%s" .Values.global.platformExternalDomain }}'<br>
  #     paths:<br>
  #       - path: /*<br>
  #         pathType: Prefix  # Optional, defaults to defaultPathType<br>
  #         serviceName: '{{ printf "%s-frontend" (include "common.names.fullname" .) }}'<br>
  #         portNumber: '{{ .Values.frontend.service.http.port }}'
  # </code></pre>
  extraHosts: []
  # -- Ingress annotations specific to your load balancer. Evaluated as a template
  annotations: {}
  # -- Additional labels for the ingress object. Evaluated as a template
  extraLabels: {}
  # -- Name of the ingress class (replaces deprecated annotation 'kubernetes.io/ingress.class')
  ingressClassName: ""
  # -- TLS configuration. Evaluated as a template
  #
  # <pre><code>
  # tls:<br>
  #   - hosts:<br>
  #       - '{{ .Values.global.platformExternalDomain }}'<br>
  #       - '{{ printf "user-data.%s" .Values.global.platformExternalDomain }}'<br>
  #     secretName: my-tls
  # </code></pre>
  tls: []

pipeline-optimization:
  enabled: true
