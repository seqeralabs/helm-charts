# yaml-language-server: $schema=https://raw.githubusercontent.com/helm-unittest/helm-unittest/main/schema/helm-testsuite.json
#
# Copyright (c) 2025 - 2026 Seqera Labs
# All rights reserved.
#
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

suite: test Platform secret
templates:
  - secret.yaml
chart:
  version: 9.8.7
  appVersion: 1.2.3-asdf
tests:
  - it: should render 1 secret by default, when no pull credentials are provided
    asserts:
      - hasDocuments:
          count: 1

  - it: should render backend secret with default values
    asserts:
      - isKind:
          of: Secret
      - equal:
          path: metadata.name
          value: release-name-platform-backend
      - equal:
          path: type
          value: Opaque

  - it: should apply common labels
    set:
      commonLabels:
        environment: "dev"
        team: "platform"
    asserts:
      - equal:
          path: metadata.labels.environment
          value: dev
      - equal:
          path: metadata.labels.team
          value: platform

  - it: should include Redis password when not using existing secret
    set:
      redis:
        password: "my-redis-password"
    asserts:
      - equal:
          path: data.TOWER_REDIS_PASSWORD
          value: my-redis-password
          decodeBase64: true

  - it: should not fetch the Redis password from existing secret because we mount the user-provided secret on the pod directly
    set:
      redis:
        existingSecretName: "unittest"
    asserts:
      - notExists:
          path: data.TOWER_REDIS_PASSWORD

  - it: should include JWT secret when not using existing secret
    set:
      platform:
        jwtSeedString: "my-jwt-seed"
    asserts:
      - equal:
          path: data.TOWER_JWT_SECRET
          value: my-jwt-seed
          decodeBase64: true

  - it: should not fetch the JWT token from existing secret because we mount the user-provided secret on the pod directly
    set:
      platform:
        jwtSeedSecretName: "unittest"
    asserts:
      - notExists:
          path: data.TOWER_JWT_SECRET

  - it: should include crypto secret when not using existing secret
    set:
      platform:
        cryptoSeedString: "my-crypto-seed"
    asserts:
      - equal:
          path: data.TOWER_CRYPTO_SECRETKEY
          value: my-crypto-seed
          decodeBase64: true

  - it: should not fetch the crypto token from existing secret because we mount the user-provided secret on the pod directly
    set:
      platform:
        cryptoSeedSecretName: "unittest"
    asserts:
      - notExists:
          path: data.TOWER_CRYPTO_SECRETKEY

  - it: should include license when not using existing secret
    set:
      platform:
        licenseString: "my-license-key"
    asserts:
      - equal:
          path: data.TOWER_LICENSE
          value: my-license-key
          decodeBase64: true

  - it: should not fetch the license token from existing secret because we mount the user-provided secret on the pod directly
    set:
      platform:
        licenseSecretName: "unittest"
    asserts:
      - notExists:
          path: data.TOWER_LICENSE

  - it: should include SMTP configuration when configured
    set:
      platform:
        smtp:
          host: "smtp.example.com"
          password: "smtp-password"
    asserts:
      - equal:
          path: data.TOWER_SMTP_PASSWORD
          value: smtp-password
          decodeBase64: true

  - it: should not fetch the SMTP password from existing secret because we mount the user-provided secret on the pod directly
    set:
      platform:
        licenseSecretName: "unittest"
    asserts:
      - notExists:
          path: data.TOWER_LICENSE

  - it: should generate JWT and Crypto secrets when not provided
    set:
      platform:
        jwtSeedString: ""
        cryptoSeedString: ""
        jwtSeedSecretName: ""
        cryptoSeedSecretName: ""
    asserts:
      - matchRegex:
          path: data.TOWER_JWT_SECRET
          pattern: "^[A-Za-z0-9@_]{35}$"
          decodeBase64: true
      - matchRegex:
          path: data.TOWER_CRYPTO_SECRETKEY
          pattern: "^[A-Za-z0-9@_]{35}$"
          decodeBase64: true

  - it: should not create any secret when all keys are coming from existing secret because we mount the user-provided secret on the pod directly
    set:
      platformDatabase:
        existingSecretName: "unittest"
      redis:
        existingSecretName: "unittest"
      platform:
        jwtSeedSecretName: "unittest"
        cryptoSeedSecretName: "unittest"
        licenseSecretName: "unittest"
        smtp:
          host: "smtp.example.com"
          existingSecretName: "unittest"
    asserts:
      - equal:
          path: data
          value: null

  - it: should create the imagepullsecret if credentials are provided
    documentSelector:
      path: metadata.name
      value: release-name-platform-imagepullsecret
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
    asserts:
      - hasDocuments:
          count: 2
      - isKind:
          of: Secret
      - equal:
          path: type
          value: kubernetes.io/dockerconfigjson
      # Check that the data block actually contains the desired credentials
      - equal:
          path: data['.dockerconfigjson']
          value: '{"auths":{"registry1.example.com/repo1":{"username":"username1","password":"password1","auth":"dXNlcm5hbWUxOnBhc3N3b3JkMQ=="}}}'
          decodeBase64: true
      # Then check that no other secrets are stored in the imagepullsecret
      - equal:
          path: data
          value:
            # This is the base64 of the string above, we double check to show that the structure
            # inside is stored correctly.
            .dockerconfigjson: eyJhdXRocyI6eyJyZWdpc3RyeTEuZXhhbXBsZS5jb20vcmVwbzEiOnsidXNlcm5hbWUiOiJ1c2VybmFtZTEiLCJwYXNzd29yZCI6InBhc3N3b3JkMSIsImF1dGgiOiJkWE5sY201aGJXVXhPbkJoYzNOM2IzSmtNUT09In19fQ==

  - it: should create the imagepullsecret with multiple credentials
    documentSelector:
      path: metadata.name
      value: release-name-platform-imagepullsecret
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
          - registry: "registry2.example.com/repo2"
            username: "username2"
            password: "password2"
    asserts:
      - equal:
          path: data['.dockerconfigjson']
          value: '{"auths":{"registry1.example.com/repo1":{"username":"username1","password":"password1","auth":"dXNlcm5hbWUxOnBhc3N3b3JkMQ=="},"registry2.example.com/repo2":{"username":"username2","password":"password2","auth":"dXNlcm5hbWUyOnBhc3N3b3JkMg=="}}}'
          decodeBase64: true
      - matchSnapshot: {}

  - it: should render annotations in all secrets when provided
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonAnnotations:
        annotation1: "value1"
        annotation2: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.annotations
          value:
            annotation1: "value1"
            annotation2: "1234"

  - it: should render annotations in all secrets when provided via platform.secretAnnotations
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      platform:
        secretAnnotations:
          labelA: "valueA"
          annotationB: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.annotations
          value:
            labelA: "valueA"
            annotationB: "1234"

  - it: should merge annotations from commonAnnotations and platform.secretAnnotations
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonAnnotations:
        annotation1: "this should get overwritten"
        annotation2: "this should stay"
      platform:
        secretAnnotations:
          annotation1: "this overrides the common annotation"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.annotations
          value:
            annotation1: "this overrides the common annotation"
            annotation2: "this should stay"

  - it: should render labels in all secrets when provided
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonLabels:
        label1: "value1"
        label2: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.labels
          value:
            label1: "value1"
            label2: "1234"
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7

  - it: should render labels in all secrets when provided via platform.secretLabels
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      platform:
        secretLabels:
          labelA: "valueA"
          labelB: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.labels
          value:
            labelA: "valueA"
            labelB: "1234"
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7

  - it: should merge labels from commonLabels and platform.secretLabels
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonLabels:
        label1: "this should get overwritten"
        label2: "this should stay"
      platform:
        secretLabels:
          label1: "this overrides the common annotation"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.labels
          value:
            label1: "this overrides the common annotation"
            label2: "this should stay"
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
