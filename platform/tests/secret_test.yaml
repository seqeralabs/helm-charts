# yaml-language-server: $schema=https://raw.githubusercontent.com/helm-unittest/helm-unittest/main/schema/helm-testsuite.json
suite: test Platform secret
templates:
  - secret.yaml
chart:
  version: 9.8.7
  appVersion: 1.2.3-asdf
tests:
  - it: should render 1 secret by default, when no pull credentials are provided
    asserts:
      - hasDocuments:
          count: 1

  - it: should render backend secret with default values
    asserts:
      - isKind:
          of: Secret
      - equal:
          path: metadata.name
          value: release-name-platform-backend
      - equal:
          path: type
          value: Opaque

  - it: should apply common labels
    set:
      commonLabels:
        environment: "dev"
        team: "platform"
    asserts:
      - equal:
          path: metadata.labels.environment
          value: dev
      - equal:
          path: metadata.labels.team
          value: platform

  - it: should include Redis password when not using existing secret
    set:
      redis:
        auth:
          enabled: true
          password: "my-redis-password"
    asserts:
      - equal:
          path: data.TOWER_REDIS_PASSWORD
          value: my-redis-password
          decodeBase64: true

  - it: should include Redis password from global when not using existing secret
    set:
      global:
        redis:
          auth:
            enabled: true
            password: "my-redis-password"
    asserts:
      - equal:
          path: data.TOWER_REDIS_PASSWORD
          value: my-redis-password
          decodeBase64: true

  - it: should overwrite Redis password from .global.redis with password from .redis
    set:
      global:
        redis:
          auth:
            enabled: true
            password: "my-redis-password"
      redis:
        auth:
          enabled: true
          password: "this takes precedence"
    asserts:
      - equal:
          path: data.TOWER_REDIS_PASSWORD
          value: this takes precedence
          decodeBase64: true

  - it: should fetch the Redis password from existing secret
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            redis-password-key: "bXktcmVkaXMtcGFzc3dvcmQxMjM=" # my-redis-password123
    set:
      # Don't create the secret with extraDeploy, because the `lookup` function talks to k8s and
      # needs the secret to already exist on the cluster in order for it to extract the value from
      # there.
      redis:
        auth:
          enabled: true
          existingSecretName: "unittest"
          existingSecretKey: "redis-password-key"
    asserts:
      - equal:
          path: data.TOWER_REDIS_PASSWORD
          value: my-redis-password123
          decodeBase64: true

  - it: should include JWT secret when not using existing secret
    set:
      tower:
        jwtSeedSecretName: ""
        jwtSeedString: "my-jwt-seed"
    asserts:
      - equal:
          path: data.TOWER_JWT_SECRET
          value: my-jwt-seed
          decodeBase64: true

  - it: should fetch the JWT token from existing secret
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            jwt-token-key: "bXktand0LXRva2VuMTIz" # my-jwt-token123
    set:
      tower:
        jwtSeedSecretName: "unittest"
        jwtSeedSecretKey: "jwt-token-key"
    asserts:
      - equal:
          path: data.TOWER_JWT_SECRET
          value: my-jwt-token123
          decodeBase64: true

  - it: should include crypto secret when not using existing secret
    set:
      tower:
        cryptoSeedSecretName: ""
        cryptoSeedString: "my-crypto-seed"
    asserts:
      - equal:
          path: data.TOWER_CRYPTO_SECRETKEY
          value: my-crypto-seed
          decodeBase64: true

  - it: should fetch the crypto token from existing secret
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            crypto-token-key: "bXktY3J5cHRvLXRva2VuMTIz" # my-crypto-token123
    set:
      tower:
        cryptoSeedSecretName: "unittest"
        cryptoSeedSecretKey: "crypto-token-key"
    asserts:
      - equal:
          path: data.TOWER_CRYPTO_SECRETKEY
          value: my-crypto-token123
          decodeBase64: true

  - it: should include license when not using existing secret
    set:
      tower:
        licenseString: "my-license-key"
    asserts:
      - equal:
          path: data.TOWER_LICENSE
          value: my-license-key
          decodeBase64: true

  - it: should fetch the license token from existing secret
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            license-token-key: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw==" # my-platform-license123
    set:
      tower:
        licenseSecretName: "unittest"
        licenseSecretKey: "license-token-key"
    asserts:
      - equal:
          path: data.TOWER_LICENSE
          value: my-platform-license123
          decodeBase64: true

  - it: should include SMTP configuration when configured
    set:
      tower:
        smtp:
          host: "smtp.example.com"
          password: "smtp-password"
    asserts:
      - equal:
          path: data.TOWER_SMTP_PASSWORD
          value: smtp-password
          decodeBase64: true

  - it: should fetch the SMTP password from existing secret
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            smtp-password-key: "bXktc210cC1wYXNzd29yZDEyMw==" # my-smtp-password123
    set:
      tower:
        licenseSecretName: "unittest"
        licenseSecretKey: "smtp-password-key"
    asserts:
      - equal:
          path: data.TOWER_LICENSE
          value: my-smtp-password123
          decodeBase64: true

  - it: should generate JWT and Crypto secrets when not provided
    set:
      tower:
        jwtSeedSecretName: ""
        cryptoSeedSecretName: ""
    asserts:
      - matchRegex:
          path: data.TOWER_JWT_SECRET
          pattern: "^[A-Za-z0-9@_]{35}$"
          decodeBase64: true
      - matchRegex:
          path: data.TOWER_CRYPTO_SECRETKEY
          pattern: "^[A-Za-z0-9@_]{35}$"
          decodeBase64: true

  - it: should work when all tokens are coming from existing secret
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            TOWER_DB_PASSWORD: "bXktZGItcGFzc3dvcmQxMjM=" # my-db-password123
            TOWER_JWT_SECRET: "bXktand0LXRva2VuMTIz" # my-jwt-token123
            TOWER_CRYPTO_SECRETKEY: "bXktY3J5cHRvLXRva2VuMTIz" # my-crypto-token123
            TOWER_LICENSE: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw==" # my-platform-license123
            TOWER_REDIS_PASSWORD: "bXktcmVkaXMtcGFzc3dvcmQxMjM=" # my-redis-password123
            TOWER_SMTP_PASSWORD: "bXktc210cC1wYXNzd29yZDEyMw==" # my-smtp-password123
    set:
      global:
        platformDatabase:
          existingSecretName: "unittest"
      redis:
        auth:
          enabled: true
          existingSecretName: "unittest"
      tower:
        jwtSeedSecretName: "unittest"
        cryptoSeedSecretName: "unittest"
        licenseSecretName: "unittest"
        smtp:
          host: "smtp.example.com"
          existingSecretName: "unittest"
    asserts:
      # The following test also makes sure that no other secrets are stored in the secret and that
      # we don't forget to test new secrets added
      - equal:
          path: data
          value:
            TOWER_DB_PASSWORD: "bXktZGItcGFzc3dvcmQxMjM="
            TOWER_JWT_SECRET: "bXktand0LXRva2VuMTIz"
            TOWER_CRYPTO_SECRETKEY: "bXktY3J5cHRvLXRva2VuMTIz"
            TOWER_LICENSE: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw=="
            TOWER_REDIS_PASSWORD: "bXktcmVkaXMtcGFzc3dvcmQxMjM="
            TOWER_SMTP_PASSWORD: "bXktc210cC1wYXNzd29yZDEyMw=="

  - it: should work when all tokens are coming from existing secret with custom keys
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: unittest
            namespace: NAMESPACE
          data:
            db-password-key: "bXktZGItcGFzc3dvcmQxMjM=" # my-db-password123
            jwt-token-key: "bXktand0LXRva2VuMTIz" # my-jwt-token123
            crypto-token-key: "bXktY3J5cHRvLXRva2VuMTIz" # my-crypto-token123
            license-token-key: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw==" # my-platform-license123
            redis-password-key: "bXktcmVkaXMtcGFzc3dvcmQxMjM=" # my-redis-password123
            smtp-password-key: "bXktc210cC1wYXNzd29yZDEyMw==" # my-smtp-password123
    set:
      global:
        platformDatabase:
          existingSecretName: "unittest"
          existingSecretKey: "db-password-key"
      redis:
        auth:
          enabled: true
          existingSecretName: "unittest"
          existingSecretKey: "redis-password-key"
      tower:
        jwtSeedSecretName: "unittest"
        jwtSeedSecretKey: "jwt-token-key"
        cryptoSeedSecretName: "unittest"
        cryptoSeedSecretKey: "crypto-token-key"
        licenseSecretName: "unittest"
        licenseSecretKey: "license-token-key"
        smtp:
          host: "smtp.example.com"
          existingSecretName: "unittest"
          existingSecretKey: "smtp-password-key"
    asserts:
      # The following test also makes sure that no other secrets are stored in the secret and that
      # we don't forget to test new secrets added
      - equal:
          path: data
          value:
            TOWER_DB_PASSWORD: "bXktZGItcGFzc3dvcmQxMjM="
            TOWER_JWT_SECRET: "bXktand0LXRva2VuMTIz"
            TOWER_CRYPTO_SECRETKEY: "bXktY3J5cHRvLXRva2VuMTIz"
            TOWER_LICENSE: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw=="
            TOWER_REDIS_PASSWORD: "bXktcmVkaXMtcGFzc3dvcmQxMjM="
            TOWER_SMTP_PASSWORD: "bXktc210cC1wYXNzd29yZDEyMw=="

  - it: should interpolate values in secret names and keys
    kubernetesProvider:
      scheme:
        "v1/Secret":
          gvr:
            version:  "v1"
            resource: "secrets"
          namespaced: true
      objects:
        - apiVersion: v1
          kind: Secret
          type: Opaque
          metadata:
            name: secret-RELEASE-NAME
            namespace: NAMESPACE
          data:
            db-password-RELEASE-NAME: "bXktZGItcGFzc3dvcmQxMjM=" # my-db-password123
            jwt-token-RELEASE-NAME: "bXktand0LXRva2VuMTIz" # my-jwt-token123
            crypto-token-RELEASE-NAME: "bXktY3J5cHRvLXRva2VuMTIz" # my-crypto-token123
            license-token-RELEASE-NAME: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw==" # my-platform-license123
            redis-password-RELEASE-NAME: "bXktcmVkaXMtcGFzc3dvcmQxMjM=" # my-redis-password123
            smtp-password-RELEASE-NAME: "bXktc210cC1wYXNzd29yZDEyMw==" # my-smtp-password123
    set:
      global:
        platformDatabase:
          existingSecretName: "secret-{{ .Release.Name }}"
          existingSecretKey: "db-password-{{ .Release.Name }}"
      redis:
        auth:
          enabled: true
          existingSecretName: "secret-{{ .Release.Name }}"
          existingSecretKey: "redis-password-{{ .Release.Name }}"
      tower:
        jwtSeedSecretName: "secret-{{ .Release.Name }}"
        jwtSeedSecretKey: "jwt-token-{{ .Release.Name }}"
        cryptoSeedSecretName: "secret-{{ .Release.Name }}"
        cryptoSeedSecretKey: "crypto-token-{{ .Release.Name }}"
        licenseSecretName: "secret-{{ .Release.Name }}"
        licenseSecretKey: "license-token-{{ .Release.Name }}"
        smtp:
          host: "smtp.example.com"
          existingSecretName: "secret-{{ .Release.Name }}"
          existingSecretKey: "smtp-password-{{ .Release.Name }}"
    asserts:
      - equal:
          path: data
          value:
            TOWER_DB_PASSWORD: "bXktZGItcGFzc3dvcmQxMjM="
            TOWER_JWT_SECRET: "bXktand0LXRva2VuMTIz"
            TOWER_CRYPTO_SECRETKEY: "bXktY3J5cHRvLXRva2VuMTIz"
            TOWER_LICENSE: "bXktcGxhdGZvcm0tbGljZW5zZTEyMw=="
            TOWER_REDIS_PASSWORD: "bXktcmVkaXMtcGFzc3dvcmQxMjM="
            TOWER_SMTP_PASSWORD: "bXktc210cC1wYXNzd29yZDEyMw=="

  - it: should create the imagepullsecret if credentials are provided
    documentSelector:
      path: metadata.name
      value: release-name-platform-imagepullsecret
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
    asserts:
      - hasDocuments:
          count: 2
      - isKind:
          of: Secret
      - equal:
          path: type
          value: kubernetes.io/dockerconfigjson
      # Check that the data block actually contains the desired credentials
      - equal:
          path: data['.dockerconfigjson']
          value: '{"auths":{"registry1.example.com/repo1":{"username":"username1","password":"password1","auth":"dXNlcm5hbWUxOnBhc3N3b3JkMQ=="}}}'
          decodeBase64: true
      # Then check that no other secrets are stored in the imagepullsecret
      - equal:
          path: data
          value:
            # This is the base64 of the string above, we double check to show that the structure
            # inside is stored correctly.
            .dockerconfigjson: eyJhdXRocyI6eyJyZWdpc3RyeTEuZXhhbXBsZS5jb20vcmVwbzEiOnsidXNlcm5hbWUiOiJ1c2VybmFtZTEiLCJwYXNzd29yZCI6InBhc3N3b3JkMSIsImF1dGgiOiJkWE5sY201aGJXVXhPbkJoYzNOM2IzSmtNUT09In19fQ==

  - it: should create the imagepullsecret with multiple credentials
    documentSelector:
      path: metadata.name
      value: release-name-platform-imagepullsecret
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
          - registry: "registry2.example.com/repo2"
            username: "username2"
            password: "password2"
    asserts:
      - equal:
          path: data['.dockerconfigjson']
          value: '{"auths":{"registry1.example.com/repo1":{"username":"username1","password":"password1","auth":"dXNlcm5hbWUxOnBhc3N3b3JkMQ=="},"registry2.example.com/repo2":{"username":"username2","password":"password2","auth":"dXNlcm5hbWUyOnBhc3N3b3JkMg=="}}}'
          decodeBase64: true
      - equal:
          path: data
          value:
            .dockerconfigjson: eyJhdXRocyI6eyJyZWdpc3RyeTEuZXhhbXBsZS5jb20vcmVwbzEiOnsidXNlcm5hbWUiOiJ1c2VybmFtZTEiLCJwYXNzd29yZCI6InBhc3N3b3JkMSIsImF1dGgiOiJkWE5sY201aGJXVXhPbkJoYzNOM2IzSmtNUT09In0sInJlZ2lzdHJ5Mi5leGFtcGxlLmNvbS9yZXBvMiI6eyJ1c2VybmFtZSI6InVzZXJuYW1lMiIsInBhc3N3b3JkIjoicGFzc3dvcmQyIiwiYXV0aCI6ImRYTmxjbTVoYldVeU9uQmhjM04zYjNKa01nPT0ifX19

  - it: should render annotations in all secrets when provided
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonAnnotations:
        annotation1: "value1"
        annotation2: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.annotations
          value:
            annotation1: "value1"
            annotation2: 1234
        documentIndex: 0
      - equal:
          path: metadata.annotations
          value:
            annotation1: "value1"
            annotation2: 1234
        documentIndex: 1

  - it: should render annotations in all secrets when provided via tower.secretAnnotations
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      tower:
        secretAnnotations:
          labelA: "valueA"
          annotationB: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.annotations
          value:
            labelA: "valueA"
            annotationB: 1234
        documentIndex: 0
      - equal:
          path: metadata.annotations
          value:
            labelA: "valueA"
            annotationB: 1234
        documentIndex: 1

  - it: should merge annotations from commonAnnotations and tower.secretAnnotations
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonAnnotations:
        annotation1: "this should get overwritten"
        annotation2: "this should stay"
      tower:
        secretAnnotations:
          annotation1: "this overrides the common annotation"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.annotations
          value:
            annotation1: "this overrides the common annotation"
            annotation2: "this should stay"
        documentIndex: 0
      - equal:
          path: metadata.annotations
          value:
            annotation1: "this overrides the common annotation"
            annotation2: "this should stay"
        documentIndex: 1

  - it: should render labels in all secrets when provided
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonLabels:
        label1: "value1"
        label2: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.labels
          value:
            label1: "value1"
            label2: 1234
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
        documentIndex: 0
      - equal:
          path: metadata.labels
          value:
            label1: "value1"
            label2: 1234
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
        documentIndex: 1

  - it: should render labels in all secrets when provided via tower.secretLabels
    set:
      global:
        platformServicePort: 1234
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      tower:
        secretLabels:
          labelA: "valueA"
          labelB: "{{ .Values.global.platformServicePort }}"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.labels
          value:
            labelA: "valueA"
            labelB: 1234
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
        documentIndex: 0
      - equal:
          path: metadata.labels
          value:
            labelA: "valueA"
            labelB: 1234
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
        documentIndex: 1

  - it: should merge labels from commonLabels and tower.secretLabels
    set:
      global:
        imageCredentials:
          - registry: "registry1.example.com/repo1"
            username: "username1"
            password: "password1"
      commonLabels:
        label1: "this should get overwritten"
        label2: "this should stay"
      tower:
        secretLabels:
          label1: "this overrides the common annotation"
    asserts:
      - hasDocuments:
          count: 2  # make sure to update this too if more secrets are added
      - equal:
          path: metadata.labels
          value:
            label1: "this overrides the common annotation"
            label2: "this should stay"
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
        documentIndex: 0
      - equal:
          path: metadata.labels
          value:
            label1: "this overrides the common annotation"
            label2: "this should stay"
            app.kubernetes.io/instance: RELEASE-NAME
            app.kubernetes.io/managed-by: Helm
            app.kubernetes.io/name: platform
            app.kubernetes.io/version: 1.2.3-asdf
            helm.sh/chart: platform-9.8.7
        documentIndex: 1
